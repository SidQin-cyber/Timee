<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®Œæ•´WebSocketåŠŸèƒ½æµ‹è¯• - çƒ­åŠ›å›¾åº”ç”¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            padding: 30px;
        }

        .section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e0e0e0;
            border-radius: 10px;
            background: #f9f9f9;
        }

        .section h2 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .control-group input,
        .control-group select,
        .control-group button {
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .control-group input,
        .control-group select {
            flex: 1;
            min-width: 150px;
        }

        .control-group button {
            background: #667eea;
            color: white;
            border: none;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-group button:hover {
            background: #5a67d8;
            transform: translateY(-2px);
        }

        .control-group button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #4CAF50;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.5);
        }

        .status-disconnected {
            background: #f44336;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5);
        }

        .status-reconnecting {
            background: #ff9800;
            box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .log-container {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 5px 10px;
            border-radius: 3px;
        }

        .log-info {
            background: rgba(52, 152, 219, 0.2);
            border-left: 3px solid #3498db;
        }

        .log-success {
            background: rgba(46, 204, 113, 0.2);
            border-left: 3px solid #2ecc71;
        }

        .log-warning {
            background: rgba(241, 196, 15, 0.2);
            border-left: 3px solid #f1c40f;
        }

        .log-error {
            background: rgba(231, 76, 60, 0.2);
            border-left: 3px solid #e74c3c;
        }

        .heatmap-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .user-area, .heatmap-area {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 10px;
            background: white;
        }

        .time-slots {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 5px;
            margin-top: 10px;
        }

        .time-slot {
            width: 40px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .time-slot:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .time-slot.selected {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .time-slot.heatmap-level-1 {
            background: rgba(102, 126, 234, 0.2);
        }

        .time-slot.heatmap-level-2 {
            background: rgba(102, 126, 234, 0.4);
        }

        .time-slot.heatmap-level-3 {
            background: rgba(102, 126, 234, 0.6);
        }

        .time-slot.heatmap-level-4 {
            background: rgba(102, 126, 234, 0.8);
        }

        .time-slot.heatmap-level-5 {
            background: rgba(102, 126, 234, 1);
            color: white;
        }

        .bug-test-section {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .bug-test-title {
            color: #856404;
            font-weight: bold;
            margin-bottom: 10px;
        }

        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .test-result {
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #ddd;
        }

        .test-result.pass {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .test-result.fail {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        .test-result.pending {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }

        .participants-list {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .participant {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: white;
            border-radius: 5px;
            margin-bottom: 8px;
            border: 1px solid #e0e0e0;
        }

        .participant:last-child {
            margin-bottom: 0;
        }

        .participant-name {
            font-weight: bold;
            color: #333;
        }

        .participant-status {
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 12px;
            color: white;
        }

        .participant-status.online {
            background: #4CAF50;
        }

        .participant-status.offline {
            background: #999;
        }

        .clear-btn {
            background: #dc3545 !important;
            margin-left: 10px;
        }

        .clear-btn:hover {
            background: #c82333 !important;
        }

        .save-indicator {
            display: inline-block;
            margin-left: 10px;
            font-size: 12px;
            padding: 3px 8px;
            border-radius: 10px;
            font-weight: bold;
        }

        .save-indicator.saving {
            background: #fff3cd;
            color: #856404;
        }

        .save-indicator.saved {
            background: #d4edda;
            color: #155724;
        }

        .save-indicator.error {
            background: #f8d7da;
            color: #721c24;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                border-radius: 10px;
            }
            
            .heatmap-container {
                grid-template-columns: 1fr;
            }
            
            .test-results {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¥ çƒ­åŠ›å›¾åº”ç”¨å®Œæ•´æµ‹è¯•</h1>
            <p>WebSocketå®æ—¶åŒæ­¥ + çŠ¶æ€æ¢å¤åŠŸèƒ½éªŒè¯</p>
        </div>

        <div class="main-content">
            <!-- è¿æ¥çŠ¶æ€ -->
            <div class="section">
                <h2>
                    <span id="connectionStatus" class="status-indicator status-disconnected"></span>
                    è¿æ¥çŠ¶æ€
                </h2>
                <div class="control-group">
                    <button id="connectBtn" onclick="connect()">è¿æ¥WebSocket</button>
                    <button id="disconnectBtn" onclick="disconnect()" disabled>æ–­å¼€è¿æ¥</button>
                    <span id="connectionInfo">æœªè¿æ¥</span>
                </div>
            </div>

            <!-- æ´»åŠ¨ç®¡ç† -->
            <div class="section">
                <h2>ğŸ“… æ´»åŠ¨ç®¡ç†</h2>
                <div class="control-group">
                    <input type="text" id="tcCodeInput" placeholder="è¾“å…¥æ´»åŠ¨ä»£ç  (ä¾‹: TEST02)">
                    <button onclick="generateTcCode()">ç”Ÿæˆæ–°ä»£ç </button>
                    <button onclick="createTestEvent()">åˆ›å»ºæµ‹è¯•æ´»åŠ¨</button>
                    <button onclick="joinEvent()">åŠ å…¥æ´»åŠ¨</button>
                </div>
                <div class="control-group">
                    <input type="text" id="participantNameInput" placeholder="å‚ä¸è€…åç§°" value="ç”¨æˆ·A">
                    <button onclick="leaveEvent()">ç¦»å¼€æ´»åŠ¨</button>
                </div>
            </div>

            <!-- Bugæµ‹è¯•åŒºåŸŸ -->
            <div class="bug-test-section">
                <div class="bug-test-title">ğŸ› Bugä¿®å¤éªŒè¯</div>
                <div class="control-group">
                    <button onclick="testBug1()">æµ‹è¯•Bug #1 (å®æ—¶åŒæ­¥)</button>
                    <button onclick="testBug2()">æµ‹è¯•Bug #2 (çŠ¶æ€æ¢å¤)</button>
                    <button onclick="simulatePageRefresh()">æ¨¡æ‹Ÿé¡µé¢åˆ·æ–°</button>
                    <button onclick="testMultiUser()">æµ‹è¯•å¤šç”¨æˆ·åœºæ™¯</button>
                </div>
                <div class="test-results" id="testResults"></div>
            </div>

            <!-- çƒ­åŠ›å›¾åŒºåŸŸ -->
            <div class="heatmap-container">
                <div class="user-area">
                    <h3>ğŸ‘¤ æˆ‘çš„å¯ç”¨æ—¶é—´ <span id="saveIndicator" class="save-indicator" style="display: none;"></span></h3>
                    <div class="time-slots" id="userTimeSlots"></div>
                    <div class="control-group" style="margin-top: 15px;">
                        <button onclick="saveUserSelection()">ä¿å­˜é€‰æ‹©</button>
                        <button onclick="clearUserSelection()" class="clear-btn">æ¸…ç©ºé€‰æ‹©</button>
                        <button onclick="restoreUserState()">æ¢å¤çŠ¶æ€</button>
                    </div>
                </div>
                
                <div class="heatmap-area">
                    <h3>ğŸ”¥ å›¢é˜Ÿçƒ­åŠ›å›¾</h3>
                    <div class="time-slots" id="heatmapTimeSlots"></div>
                    <div class="participants-list" id="participantsList">
                        <div style="text-align: center; color: #666;">ç­‰å¾…åŠ å…¥æ´»åŠ¨...</div>
                    </div>
                </div>
            </div>

            <!-- å®æ—¶æ—¥å¿— -->
            <div class="section">
                <h2>ğŸ“‹ å®æ—¶æ—¥å¿—</h2>
                <div class="control-group">
                    <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
                    <button onclick="exportLog()">å¯¼å‡ºæ—¥å¿—</button>
                    <label>
                        <input type="checkbox" id="autoScroll" checked> è‡ªåŠ¨æ»šåŠ¨
                    </label>
                </div>
                <div class="log-container" id="logContainer"></div>
            </div>
        </div>
    </div>

    <script src="websocket-client.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let client = null;
        let currentEvent = null;
        let currentParticipant = null;
        let userSelection = new Set();
        let testResults = new Map();

        // åˆå§‹åŒ–é¡µé¢
        document.addEventListener('DOMContentLoaded', function() {
            initializeTimeSlots();
            log('é¡µé¢åŠ è½½å®Œæˆ', 'info');
        });

        // åˆå§‹åŒ–æ—¶é—´æ®µ
        function initializeTimeSlots() {
            const days = ['å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­', 'å‘¨æ—¥'];
            const hours = ['09:00', '10:00', '11:00', '14:00', '15:00', '16:00', '17:00'];
            
            const userSlots = document.getElementById('userTimeSlots');
            const heatmapSlots = document.getElementById('heatmapTimeSlots');
            
            userSlots.innerHTML = '';
            heatmapSlots.innerHTML = '';
            
            days.forEach((day, dayIndex) => {
                hours.forEach((hour, hourIndex) => {
                    const slotId = `${dayIndex}-${hourIndex}`;
                    
                    // ç”¨æˆ·é€‰æ‹©åŒºåŸŸ
                    const userSlot = document.createElement('div');
                    userSlot.className = 'time-slot';
                    userSlot.id = `user-${slotId}`;
                    userSlot.textContent = `${day.substr(1)}${hour.substr(0,2)}`;
                    userSlot.title = `${day} ${hour}`;
                    userSlot.onclick = () => toggleTimeSlot(slotId);
                    userSlots.appendChild(userSlot);
                    
                    // çƒ­åŠ›å›¾åŒºåŸŸ
                    const heatmapSlot = document.createElement('div');
                    heatmapSlot.className = 'time-slot';
                    heatmapSlot.id = `heatmap-${slotId}`;
                    heatmapSlot.textContent = `${day.substr(1)}${hour.substr(0,2)}`;
                    heatmapSlot.title = `${day} ${hour}`;
                    heatmapSlots.appendChild(heatmapSlot);
                });
            });
        }

        // åˆ‡æ¢æ—¶é—´æ®µé€‰æ‹©
        function toggleTimeSlot(slotId) {
            const userSlot = document.getElementById(`user-${slotId}`);
            
            if (userSelection.has(slotId)) {
                userSelection.delete(slotId);
                userSlot.classList.remove('selected');
            } else {
                userSelection.add(slotId);
                userSlot.classList.add('selected');
            }
            
            showSaveIndicator('saving');
            log(`æ—¶é—´æ®µ ${slotId} ${userSelection.has(slotId) ? 'é€‰ä¸­' : 'å–æ¶ˆé€‰ä¸­'}`, 'info');
        }

        // è¿æ¥WebSocket
        async function connect() {
            try {
                showSaveIndicator('saving');
                log('å¼€å§‹è¿æ¥WebSocketæœåŠ¡å™¨...', 'info');
                
                client = new TimeeWebSocketClient({
                    debug: true,
                    apiUrl: 'http://localhost:3000/api',
                    wsUrl: 'http://localhost:3000'
                });

                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                setupEventListeners();

                await client.connect();
                
                updateConnectionStatus(true);
                log('WebSocketè¿æ¥æˆåŠŸ', 'success');
                showSaveIndicator('saved');
                
            } catch (error) {
                log(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                showSaveIndicator('error');
                updateConnectionStatus(false);
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnect() {
            if (client) {
                client.disconnect();
                client = null;
            }
            updateConnectionStatus(false);
            log('WebSocketè¿æ¥å·²æ–­å¼€', 'info');
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
        function setupEventListeners() {
            if (!client) return;

            client.on('initial-state', (data) => {
                log('æ”¶åˆ°åˆå§‹çŠ¶æ€æ•°æ®', 'success');
                updateHeatmap(data.heatmap);
                updateParticipants(data.participants);
                updateTestResult('initial-state', true, 'åˆå§‹çŠ¶æ€åŠ è½½æˆåŠŸ');
            });

            client.on('room-update', (data) => {
                log('æ”¶åˆ°æˆ¿é—´æ›´æ–°: ' + JSON.stringify(data), 'info');
                updateHeatmap(data.heatmap);
                updateParticipants(data.participants);
                updateTestResult('realtime-sync', true, 'å®æ—¶åŒæ­¥æ­£å¸¸å·¥ä½œ');
            });

            client.on('response-updated', (data) => {
                log('æ”¶åˆ°å“åº”æ›´æ–°: ' + JSON.stringify(data), 'info');
                updateHeatmap(data.heatmap);
                updateTestResult('response-sync', true, 'å“åº”åŒæ­¥æ­£å¸¸');
            });

            client.on('user-joined', (data) => {
                log(`ç”¨æˆ·åŠ å…¥: ${data.participantName}`, 'success');
                updateParticipants(data.participants);
            });

            client.on('user-left', (data) => {
                log(`ç”¨æˆ·ç¦»å¼€: ${data.participantName}`, 'warning');
                updateParticipants(data.participants);
            });

            client.on('state-restored', (data) => {
                log('çŠ¶æ€æ¢å¤å®Œæˆ', 'success');
                updateUserSelection(data.userResponse);
                updateHeatmap(data.roomData.heatmap);
                updateParticipants(data.roomData.participants);
                updateTestResult('state-recovery', true, 'çŠ¶æ€æ¢å¤æˆåŠŸ');
            });

            client.on('error', (error) => {
                log(`WebSocketé”™è¯¯: ${error.message || error}`, 'error');
                updateTestResult('error-handling', false, `é”™è¯¯: ${error.message}`);
            });

            client.on('disconnected', (data) => {
                log(`è¿æ¥æ–­å¼€: ${data.reason}`, 'warning');
                updateConnectionStatus(false);
            });
        }

        // ç”ŸæˆtcCode
        async function generateTcCode() {
            try {
                if (!client) {
                    log('è¯·å…ˆè¿æ¥WebSocketæœåŠ¡å™¨', 'error');
                    return;
                }

                const tcCode = await client.generateTcCode();
                document.getElementById('tcCodeInput').value = tcCode;
                log(`ç”Ÿæˆæ–°çš„æ´»åŠ¨ä»£ç : ${tcCode}`, 'success');
            } catch (error) {
                log(`ç”Ÿæˆä»£ç å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åˆ›å»ºæµ‹è¯•æ´»åŠ¨
        async function createTestEvent() {
            try {
                if (!client) {
                    log('è¯·å…ˆè¿æ¥WebSocketæœåŠ¡å™¨', 'error');
                    return;
                }

                const tcCode = document.getElementById('tcCodeInput').value || await client.generateTcCode();
                
                const eventData = {
                    tcCode: tcCode,
                    title: 'æµ‹è¯•æ´»åŠ¨',
                    description: 'ç”¨äºæµ‹è¯•WebSocketåŠŸèƒ½çš„æ´»åŠ¨',
                    startDate: new Date().toISOString(),
                    endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                    timezone: 'UTC'
                };

                currentEvent = await client.createEvent(eventData);
                document.getElementById('tcCodeInput').value = tcCode;
                log(`åˆ›å»ºæ´»åŠ¨æˆåŠŸ: ${tcCode}`, 'success');
                
            } catch (error) {
                log(`åˆ›å»ºæ´»åŠ¨å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // åŠ å…¥æ´»åŠ¨
        async function joinEvent() {
            try {
                if (!client) {
                    log('è¯·å…ˆè¿æ¥WebSocketæœåŠ¡å™¨', 'error');
                    return;
                }

                const tcCode = document.getElementById('tcCodeInput').value;
                const participantName = document.getElementById('participantNameInput').value;
                
                if (!tcCode || !participantName) {
                    log('è¯·è¾“å…¥æ´»åŠ¨ä»£ç å’Œå‚ä¸è€…åç§°', 'error');
                    return;
                }

                // è·å–æ´»åŠ¨ä¿¡æ¯
                currentEvent = await client.getEvent(tcCode);
                currentParticipant = participantName;
                
                // åŠ å…¥æ´»åŠ¨æˆ¿é—´
                await client.joinEvent(currentEvent.id, participantName);
                
                log(`æˆåŠŸåŠ å…¥æ´»åŠ¨: ${tcCode} (${participantName})`, 'success');
                updateTestResult('join-event', true, 'æˆåŠŸåŠ å…¥æ´»åŠ¨');
                
            } catch (error) {
                log(`åŠ å…¥æ´»åŠ¨å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('join-event', false, `åŠ å…¥å¤±è´¥: ${error.message}`);
            }
        }

        // ç¦»å¼€æ´»åŠ¨
        function leaveEvent() {
            if (client) {
                client.leaveEvent();
                currentEvent = null;
                currentParticipant = null;
                log('å·²ç¦»å¼€æ´»åŠ¨', 'info');
                
                // æ¸…ç©ºç•Œé¢
                document.getElementById('participantsList').innerHTML = 
                    '<div style="text-align: center; color: #666;">ç­‰å¾…åŠ å…¥æ´»åŠ¨...</div>';
                clearHeatmap();
            }
        }

        // ä¿å­˜ç”¨æˆ·é€‰æ‹©
        async function saveUserSelection() {
            try {
                if (!client || !currentEvent) {
                    log('è¯·å…ˆè¿æ¥å¹¶åŠ å…¥æ´»åŠ¨', 'error');
                    return;
                }

                showSaveIndicator('saving');
                
                const availability = Array.from(userSelection).map(slotId => {
                    const [day, hour] = slotId.split('-').map(Number);
                    return { day, hour, available: true };
                });

                const result = await client.submitResponse({
                    availability: availability,
                    paintMode: 'individual'
                });

                log('ç”¨æˆ·é€‰æ‹©ä¿å­˜æˆåŠŸ', 'success');
                showSaveIndicator('saved');
                updateTestResult('save-response', true, 'å“åº”ä¿å­˜æˆåŠŸ');
                
            } catch (error) {
                log(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
                showSaveIndicator('error');
                updateTestResult('save-response', false, `ä¿å­˜å¤±è´¥: ${error.message}`);
            }
        }

        // æ¸…ç©ºç”¨æˆ·é€‰æ‹©
        function clearUserSelection() {
            userSelection.clear();
            document.querySelectorAll('#userTimeSlots .time-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            log('ç”¨æˆ·é€‰æ‹©å·²æ¸…ç©º', 'info');
        }

        // æ¢å¤ç”¨æˆ·çŠ¶æ€
        async function restoreUserState() {
            try {
                if (!client || !currentEvent || !currentParticipant) {
                    log('è¯·å…ˆè¿æ¥å¹¶åŠ å…¥æ´»åŠ¨', 'error');
                    return;
                }

                const { roomData, userResponse } = await client.restoreUserState(
                    currentEvent.id, 
                    currentParticipant
                );

                log('çŠ¶æ€æ¢å¤æˆåŠŸ', 'success');
                updateTestResult('state-recovery', true, 'çŠ¶æ€æ¢å¤æˆåŠŸ');
                
            } catch (error) {
                log(`çŠ¶æ€æ¢å¤å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('state-recovery', false, `çŠ¶æ€æ¢å¤å¤±è´¥: ${error.message}`);
            }
        }

        // æ›´æ–°ç”¨æˆ·é€‰æ‹©æ˜¾ç¤º
        function updateUserSelection(userResponse) {
            if (!userResponse || !userResponse.availability) return;

            clearUserSelection();
            
            userResponse.availability.forEach(slot => {
                if (slot.available) {
                    const slotId = `${slot.day}-${slot.hour}`;
                    userSelection.add(slotId);
                    const element = document.getElementById(`user-${slotId}`);
                    if (element) {
                        element.classList.add('selected');
                    }
                }
            });

            log(`æ¢å¤ç”¨æˆ·é€‰æ‹©: ${userSelection.size} ä¸ªæ—¶é—´æ®µ`, 'info');
        }

        // æ›´æ–°çƒ­åŠ›å›¾
        function updateHeatmap(heatmapData) {
            if (!heatmapData) return;

            // æ¸…ç©ºå½“å‰çƒ­åŠ›å›¾
            clearHeatmap();

            // æ›´æ–°çƒ­åŠ›å›¾æ•°æ®
            heatmapData.forEach(slot => {
                const slotId = `${slot.day}-${slot.hour}`;
                const element = document.getElementById(`heatmap-${slotId}`);
                if (element) {
                    const level = Math.min(5, Math.max(1, slot.count));
                    element.classList.add(`heatmap-level-${level}`);
                    element.title = `${element.title} - ${slot.count} äººå¯ç”¨`;
                }
            });

            log(`çƒ­åŠ›å›¾æ›´æ–°: ${heatmapData.length} ä¸ªæ—¶é—´æ®µ`, 'info');
        }

        // æ¸…ç©ºçƒ­åŠ›å›¾
        function clearHeatmap() {
            document.querySelectorAll('#heatmapTimeSlots .time-slot').forEach(slot => {
                slot.className = 'time-slot';
            });
        }

        // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
        function updateParticipants(participants) {
            const container = document.getElementById('participantsList');
            
            if (!participants || participants.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: #666;">æš‚æ— å‚ä¸è€…</div>';
                return;
            }

            container.innerHTML = participants.map(p => `
                <div class="participant">
                    <span class="participant-name">${p.name}</span>
                    <span class="participant-status ${p.hasResponse ? 'online' : 'offline'}">
                        ${p.hasResponse ? 'å·²å“åº”' : 'æœªå“åº”'}
                    </span>
                </div>
            `).join('');

            log(`å‚ä¸è€…åˆ—è¡¨æ›´æ–°: ${participants.length} äºº`, 'info');
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(connected) {
            const indicator = document.getElementById('connectionStatus');
            const info = document.getElementById('connectionInfo');
            const connectBtn = document.getElementById('connectBtn');
            const disconnectBtn = document.getElementById('disconnectBtn');

            if (connected) {
                indicator.className = 'status-indicator status-connected';
                info.textContent = 'å·²è¿æ¥';
                connectBtn.disabled = true;
                disconnectBtn.disabled = false;
            } else {
                indicator.className = 'status-indicator status-disconnected';
                info.textContent = 'æœªè¿æ¥';
                connectBtn.disabled = false;
                disconnectBtn.disabled = true;
            }
        }

        // æ˜¾ç¤ºä¿å­˜çŠ¶æ€æŒ‡ç¤ºå™¨
        function showSaveIndicator(state) {
            const indicator = document.getElementById('saveIndicator');
            indicator.style.display = 'inline-block';
            indicator.className = `save-indicator ${state}`;
            
            switch (state) {
                case 'saving':
                    indicator.textContent = 'ä¿å­˜ä¸­...';
                    break;
                case 'saved':
                    indicator.textContent = 'å·²ä¿å­˜';
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 2000);
                    break;
                case 'error':
                    indicator.textContent = 'ä¿å­˜å¤±è´¥';
                    setTimeout(() => {
                        indicator.style.display = 'none';
                    }, 3000);
                    break;
            }
        }

        // Bugæµ‹è¯•å‡½æ•°
        async function testBug1() {
            log('å¼€å§‹æµ‹è¯•Bug #1: å®æ—¶åŒæ­¥', 'info');
            updateTestResult('bug1-test', 'pending', 'æµ‹è¯•è¿›è¡Œä¸­...');
            
            try {
                // æ¨¡æ‹Ÿç”¨æˆ·æ“ä½œ
                userSelection.add('0-0');
                await saveUserSelection();
                
                // ç­‰å¾…å®æ—¶åŒæ­¥
                setTimeout(() => {
                    if (testResults.get('realtime-sync')) {
                        updateTestResult('bug1-test', true, 'Bug #1 å·²ä¿®å¤ - å®æ—¶åŒæ­¥æ­£å¸¸');
                    } else {
                        updateTestResult('bug1-test', false, 'Bug #1 ä»å­˜åœ¨ - å®æ—¶åŒæ­¥å¤±è´¥');
                    }
                }, 2000);
                
            } catch (error) {
                updateTestResult('bug1-test', false, `Bug #1 æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        async function testBug2() {
            log('å¼€å§‹æµ‹è¯•Bug #2: çŠ¶æ€æ¢å¤', 'info');
            updateTestResult('bug2-test', 'pending', 'æµ‹è¯•è¿›è¡Œä¸­...');
            
            try {
                // ä¿å­˜å½“å‰çŠ¶æ€
                await saveUserSelection();
                
                // æ¨¡æ‹Ÿé¡µé¢åˆ·æ–°
                await simulatePageRefresh();
                
                // å°è¯•æ¢å¤çŠ¶æ€
                await restoreUserState();
                
                if (testResults.get('state-recovery')) {
                    updateTestResult('bug2-test', true, 'Bug #2 å·²ä¿®å¤ - çŠ¶æ€æ¢å¤æ­£å¸¸');
                } else {
                    updateTestResult('bug2-test', false, 'Bug #2 ä»å­˜åœ¨ - çŠ¶æ€æ¢å¤å¤±è´¥');
                }
                
            } catch (error) {
                updateTestResult('bug2-test', false, `Bug #2 æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        async function simulatePageRefresh() {
            log('æ¨¡æ‹Ÿé¡µé¢åˆ·æ–°...', 'info');
            
            // ä¿å­˜å½“å‰çŠ¶æ€
            const savedEvent = currentEvent;
            const savedParticipant = currentParticipant;
            const savedSelection = new Set(userSelection);
            
            // æ–­å¼€è¿æ¥
            disconnect();
            
            // æ¸…ç©ºç•Œé¢
            clearUserSelection();
            clearHeatmap();
            
            // ç­‰å¾…ä¸€ä¸‹
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // é‡æ–°è¿æ¥
            await connect();
            
            // é‡æ–°åŠ å…¥æ´»åŠ¨
            if (savedEvent && savedParticipant) {
                document.getElementById('tcCodeInput').value = savedEvent.tcCode;
                document.getElementById('participantNameInput').value = savedParticipant;
                await joinEvent();
            }
            
            log('é¡µé¢åˆ·æ–°æ¨¡æ‹Ÿå®Œæˆ', 'success');
        }

        async function testMultiUser() {
            log('å¼€å§‹æµ‹è¯•å¤šç”¨æˆ·åœºæ™¯', 'info');
            updateTestResult('multi-user-test', 'pending', 'æµ‹è¯•è¿›è¡Œä¸­...');
            
            try {
                // æ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·åŒæ—¶æ“ä½œ
                const users = ['ç”¨æˆ·A', 'ç”¨æˆ·B', 'ç”¨æˆ·C'];
                
                for (const user of users) {
                    // è¿™é‡Œå¯ä»¥æ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·çš„æ“ä½œ
                    log(`æ¨¡æ‹Ÿ ${user} çš„æ“ä½œ`, 'info');
                }
                
                updateTestResult('multi-user-test', true, 'å¤šç”¨æˆ·æµ‹è¯•å®Œæˆ');
                
            } catch (error) {
                updateTestResult('multi-user-test', false, `å¤šç”¨æˆ·æµ‹è¯•å¤±è´¥: ${error.message}`);
            }
        }

        // æ›´æ–°æµ‹è¯•ç»“æœ
        function updateTestResult(testId, status, message) {
            testResults.set(testId, status);
            
            const container = document.getElementById('testResults');
            const existing = document.getElementById(`test-${testId}`);
            
            const statusClass = status === true ? 'pass' : status === false ? 'fail' : 'pending';
            const statusText = status === true ? 'âœ… é€šè¿‡' : status === false ? 'âŒ å¤±è´¥' : 'â³ è¿›è¡Œä¸­';
            
            const html = `
                <div class="test-result ${statusClass}" id="test-${testId}">
                    <strong>${statusText}</strong>
                    <div>${message}</div>
                </div>
            `;
            
            if (existing) {
                existing.outerHTML = html;
            } else {
                container.insertAdjacentHTML('beforeend', html);
            }
        }

        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const container = document.getElementById('logContainer');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<strong>${timestamp}</strong> ${message}`;
            
            container.appendChild(logEntry);
            
            // è‡ªåŠ¨æ»šåŠ¨
            if (document.getElementById('autoScroll').checked) {
                container.scrollTop = container.scrollHeight;
            }
            
            // é™åˆ¶æ—¥å¿—æ¡æ•°
            if (container.children.length > 100) {
                container.removeChild(container.firstChild);
            }
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            document.getElementById('logContainer').innerHTML = '';
            log('æ—¥å¿—å·²æ¸…ç©º', 'info');
        }

        // å¯¼å‡ºæ—¥å¿—
        function exportLog() {
            const logs = Array.from(document.querySelectorAll('.log-entry'))
                .map(entry => entry.textContent)
                .join('\n');
            
            const blob = new Blob([logs], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `timee-test-log-${new Date().toISOString().split('T')[0]}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            
            log('æ—¥å¿—å·²å¯¼å‡º', 'success');
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', function() {
            if (client) {
                client.disconnect();
            }
        });
    </script>
</body>
</html> 