# 热力图问题分析和修复方案

## 🔍 发现的核心问题

### 问题1: 热力图计算逻辑中的数据分离不彻底

**问题描述：**
在 `useEventStore.ts` 的 `calculateHeatmapData` 函数中，当前用户的本地选择和其他用户的已提交数据混合处理，导致以下问题：

1. **当前用户数据重复计算**：如果当前用户已提交数据，其本地选择仍可能被重复添加
2. **实时显示不准确**：当前用户的本地选择可能覆盖其他用户的数据
3. **paintMode处理复杂**：不可行时间模式的逻辑过于复杂，容易出错

**代码位置：**
```typescript
// timee-frontend/apps/web/src/store/useEventStore.ts:190-254
// 添加当前用户的本地选择（如果存在且还未提交）
if (currentUser && currentUser.localSelection.length > 0) {
  const currentUserAlreadySubmitted = userResponses.some(
    response => response.userName === currentUser.userName
  )
  
  if (!currentUserAlreadySubmitted) {
    allUsers.push({
      userName: currentUser.userName,
      paintMode: currentUser.paintMode,
      availability: currentUser.localSelection
    })
  }
}
```

### 问题2: getHeatmapIntensity 只计算已提交用户

**问题描述：**
在 `getHeatmapIntensity` 方法中，只使用 `userResponses.length` 作为总参与者数量，忽略了当前用户的本地选择：

```typescript
// 问题代码
getHeatmapIntensity: (dateIndex: number, timeIndex: number): number => {
  const { heatmapData, userResponses } = get()
  const totalParticipants = userResponses.length  // ❌ 只计算已提交用户
  if (totalParticipants === 0) return 0
  return slotData.count / totalParticipants
}
```

这导致热力图强度计算不准确，当前用户的选择不被计入总数。

### 问题3: 实时数据同步时机不当

**问题描述：**
在 `subscribeToRealtime` 中，WebSocket事件处理逻辑有问题：

1. **数据解析错误**：`availableSlots` 可能是字符串数组，直接 `JSON.parse` 会出错
2. **热力图重新计算时机**：每次收到WebSocket事件都重新计算，但可能使用的是旧数据

## 🔧 修复方案

### 修复1: 重构热力图计算逻辑

创建更清晰的数据分离和计算逻辑：

```typescript
// 新的热力图计算逻辑
const calculateHeatmapData = (
  userResponses: UserResponse[], 
  currentUser: CurrentUserState | null,
  currentEvent: Event | null
): HeatmapData => {
  const heatmap: HeatmapData = {}
  
  if (!currentEvent) return heatmap
  
  // 1. 初始化时间网格
  const allTimeSlots = getEventTimeGrid(currentEvent)
  allTimeSlots.forEach(slot => {
    const key = `${slot.dateIndex}-${slot.timeIndex}`
    heatmap[key] = { count: 0, userNames: [] }
  })
  
  // 2. 处理已提交的用户数据
  userResponses.forEach(response => {
    processUserAvailability(heatmap, response, allTimeSlots, currentEvent)
  })
  
  // 3. 处理当前用户的本地选择（如果未提交）
  if (currentUser && currentUser.localSelection.length > 0) {
    const currentUserAlreadySubmitted = userResponses.some(
      response => response.userName === currentUser.userName
    )
    
    if (!currentUserAlreadySubmitted) {
      const currentUserResponse = {
        userName: currentUser.userName,
        paintMode: currentUser.paintMode,
        availability: currentUser.localSelection
      }
      processUserAvailability(heatmap, currentUserResponse, allTimeSlots, currentEvent)
    }
  }
  
  return heatmap
}

// 独立的用户可用性处理函数
const processUserAvailability = (
  heatmap: HeatmapData,
  user: { userName: string, paintMode: string, availability: TimeSlot[] },
  allTimeSlots: { dateIndex: number, timeIndex: number }[],
  currentEvent: Event
) => {
  if (user.paintMode === 'available') {
    // 可行时间模式：只统计选中的时间段
    user.availability.forEach(slot => {
      const key = `${slot.dateIndex}-${slot.timeIndex}`
      if (heatmap[key] && !heatmap[key].userNames.includes(user.userName)) {
        heatmap[key].count++
        heatmap[key].userNames.push(user.userName)
      }
    })
  } else {
    // 不可行时间模式：统计所有未选中的时间段
    const unavailableSlots = new Set(
      user.availability.map(slot => `${slot.dateIndex}-${slot.timeIndex}`)
    )
    
    allTimeSlots.forEach(slot => {
      const key = `${slot.dateIndex}-${slot.timeIndex}`
      if (!unavailableSlots.has(key)) {
        if (heatmap[key] && !heatmap[key].userNames.includes(user.userName)) {
          heatmap[key].count++
          heatmap[key].userNames.push(user.userName)
        }
      }
    })
  }
}
```

### 修复2: 修正热力图强度计算

```typescript
// 修复后的强度计算
getHeatmapIntensity: (dateIndex: number, timeIndex: number): number => {
  const { heatmapData, userResponses, currentUser } = get()
  const key = `${dateIndex}-${timeIndex}`
  const slotData = heatmapData[key]
  
  if (!slotData) return 0
  
  // 计算总参与者数量（包括当前用户）
  let totalParticipants = userResponses.length
  
  // 如果当前用户存在且未提交，则加1
  if (currentUser && currentUser.localSelection.length > 0) {
    const currentUserAlreadySubmitted = userResponses.some(
      response => response.userName === currentUser.userName
    )
    if (!currentUserAlreadySubmitted) {
      totalParticipants++
    }
  }
  
  if (totalParticipants === 0) return 0
  return slotData.count / totalParticipants
}
```

### 修复3: 改进实时数据同步

```typescript
// 修复WebSocket数据解析
const unsubscribeParticipantsUpdated = wsClient.on('participants-updated', (data) => {
  console.log('👥 Real-time participants updated:', data)
  if (data.eventId === eventId) {
    try {
      // 安全的数据解析
      const userResponses = data.participants.map((apiResponse: ApiEventResponse): UserResponse => {
        let availability = []
        
        if (apiResponse.availableSlots) {
          if (typeof apiResponse.availableSlots === 'string') {
            try {
              availability = JSON.parse(apiResponse.availableSlots)
            } catch (e) {
              console.warn('Failed to parse availableSlots as JSON:', e)
              availability = []
            }
          } else if (Array.isArray(apiResponse.availableSlots)) {
            availability = apiResponse.availableSlots.map(slot => 
              typeof slot === 'string' ? JSON.parse(slot) : slot
            )
          }
        }
        
        return {
          userId: apiResponse.id,
          userName: apiResponse.participantName,
          userInitials: apiResponse.userInitials,
          availability,
          paintMode: apiResponse.paintMode?.toLowerCase() as 'available' | 'unavailable',
          timezone: apiResponse.timezone,
          submittedAt: apiResponse.createdAt,
        }
      })
      
      const heatmapData = calculateHeatmapData(userResponses, get().currentUser, get().currentEvent)
      
      set({
        userResponses,
        heatmapData,
        lastDataFetch: Date.now()
      })
    } catch (error) {
      console.error('Error processing participants update:', error)
    }
  }
})
```

### 修复4: 优化数据刷新机制

```typescript
// 在 EventPage.tsx 中优化刷新逻辑
useEffect(() => {
  if (!eventId) return

  // 立即执行一次刷新
  refreshUserResponses(eventId)

  // 减少轮询间隔，提高实时性
  const interval = setInterval(() => {
    refreshUserResponses(eventId)
  }, 1000) // 从2000ms减少到1000ms

  return () => clearInterval(interval)
}, [eventId, refreshUserResponses])
```

## 🧪 测试计划

### 测试1: 热力图计算准确性
- [ ] 测试多用户可行时间模式
- [ ] 测试多用户不可行时间模式
- [ ] 测试混合模式（部分用户可行，部分不可行）
- [ ] 测试当前用户本地选择的实时显示

### 测试2: 实时同步
- [ ] 测试WebSocket连接和房间加入
- [ ] 测试用户提交数据后的实时广播
- [ ] 测试网络断开时的轮询fallback
- [ ] 测试数据解析的容错性

### 测试3: 边界情况
- [ ] 测试无用户数据时的热力图显示
- [ ] 测试单用户时的热力图计算
- [ ] 测试大量用户时的性能表现
- [ ] 测试时区转换的准确性

## 📋 实施步骤

1. **立即修复**：修复热力图计算逻辑中的数据重复问题
2. **优化强度计算**：修正 `getHeatmapIntensity` 方法的参与者计数
3. **改进数据解析**：增强WebSocket数据解析的容错性
4. **测试验证**：使用测试工具验证修复效果
5. **性能优化**：减少不必要的重新计算

## 🎯 预期效果

修复后应该实现：
- ✅ 多用户时间选择能够正确同时显示
- ✅ 热力图强度计算准确
- ✅ 实时同步响应及时
- ✅ 数据解析容错性强
- ✅ 当前用户选择与其他用户数据正确分离 