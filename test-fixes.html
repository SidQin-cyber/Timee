<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¿®å¤éªŒè¯æµ‹è¯•</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #e1e5e9;
            border-radius: 6px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #24292e;
        }
        .status {
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: 500;
            display: inline-block;
            margin: 5px 0;
        }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }
        .status.info { background: #d1ecf1; color: #0c5460; }
        .status.warning { background: #fff3cd; color: #856404; }
        .log {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 12px;
            max-height: 200px;
            overflow-y: auto;
        }
        button {
            background: #0366d6;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0256cc;
        }
        button:disabled {
            background: #6c757d;
            cursor: not-allowed;
        }
        .user-simulation {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        .user-card {
            flex: 1;
            border: 1px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            background: #fafafa;
        }
        .user-card h4 {
            margin-top: 0;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ Timee ä¿®å¤éªŒè¯æµ‹è¯•</h1>
        <p>éªŒè¯çƒ­åŠ›å›¾è®¡ç®—é€»è¾‘å’Œå®æ—¶åŒæ­¥åŠŸèƒ½çš„ä¿®å¤æ•ˆæœ</p>

        <!-- æµ‹è¯•é…ç½® -->
        <div class="test-section">
            <h3>ğŸ“‹ æµ‹è¯•é…ç½®</h3>
            <label>
                äº‹ä»¶ID: 
                <input type="text" id="eventId" value="tc-realtime-test" style="margin-left: 10px; padding: 5px;">
            </label>
            <br>
            <label>
                APIåœ°å€: 
                <input type="text" id="apiUrl" value="http://localhost:3000/api" style="margin-left: 10px; padding: 5px; width: 300px;">
            </label>
            <button onclick="testSystemConnection()">ğŸ”— æµ‹è¯•è¿æ¥</button>
            <div id="connectionStatus" class="status info">ç­‰å¾…æµ‹è¯•</div>
        </div>

        <!-- çƒ­åŠ›å›¾è®¡ç®—æµ‹è¯• -->
        <div class="test-section">
            <h3>ğŸ”¥ çƒ­åŠ›å›¾è®¡ç®—é€»è¾‘æµ‹è¯•</h3>
            <p>æµ‹è¯•å¯è¡Œæ—¶é—´æ¨¡å¼ä¸‹é€‰æ‹©ä¸€ä¸ªæ—¶é—´æ®µæ˜¯å¦æ­£ç¡®æ˜¾ç¤ºï¼Œè€Œä¸æ˜¯å…¨é€‰</p>
            
            <button onclick="testHeatmapLogic()">ğŸ§ª æµ‹è¯•çƒ­åŠ›å›¾è®¡ç®—</button>
            <button onclick="clearTestData()">ğŸ§¹ æ¸…ç†æµ‹è¯•æ•°æ®</button>
            
            <div id="heatmapTestStatus" class="status info">ç­‰å¾…æµ‹è¯•</div>
            <div id="heatmapTestLog" class="log"></div>
        </div>

        <!-- å®æ—¶åŒæ­¥æµ‹è¯• -->
        <div class="test-section">
            <h3>ğŸ“¡ å®æ—¶åŒæ­¥æµ‹è¯•</h3>
            <p>æ¨¡æ‹Ÿå¤šä¸ªç”¨æˆ·åŒæ—¶æ“ä½œï¼ŒéªŒè¯ç¬¬ä¸€ä¸ªå’Œç¬¬äºŒä¸ªç”¨æˆ·æ˜¯å¦èƒ½ç«‹å³çœ‹åˆ°å½¼æ­¤çš„é€‰æ‹©</p>
            
            <button onclick="startRealtimeTest()">ğŸš€ å¼€å§‹å®æ—¶åŒæ­¥æµ‹è¯•</button>
            <button onclick="stopRealtimeTest()">â¹ï¸ åœæ­¢æµ‹è¯•</button>
            
            <div id="realtimeTestStatus" class="status info">ç­‰å¾…æµ‹è¯•</div>
            
            <!-- ç”¨æˆ·æ¨¡æ‹Ÿ -->
            <div class="user-simulation">
                <div class="user-card">
                    <h4>ğŸ‘¤ ç”¨æˆ·1</h4>
                    <div id="user1Status" class="status info">æœªè¿æ¥</div>
                    <button onclick="simulateUser1Action()">é€‰æ‹©æ—¶é—´æ®µ</button>
                </div>
                <div class="user-card">
                    <h4>ğŸ‘¤ ç”¨æˆ·2</h4>
                    <div id="user2Status" class="status info">æœªè¿æ¥</div>
                    <button onclick="simulateUser2Action()">é€‰æ‹©æ—¶é—´æ®µ</button>
                </div>
                <div class="user-card">
                    <h4>ğŸ‘¤ ç”¨æˆ·3</h4>
                    <div id="user3Status" class="status info">æœªè¿æ¥</div>
                    <button onclick="simulateUser3Action()">é€‰æ‹©æ—¶é—´æ®µ</button>
                </div>
            </div>
            
            <div id="realtimeTestLog" class="log"></div>
        </div>

        <!-- ç»¼åˆæµ‹è¯•ç»“æœ -->
        <div class="test-section">
            <h3>ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»</h3>
            <div id="testSummary" class="log">ç­‰å¾…æµ‹è¯•å®Œæˆ...</div>
        </div>
    </div>

    <script>
        const eventId = 'tc-realtime-test';
        let apiUrl = 'http://localhost:3000/api';
        let testResults = {
            connection: false,
            heatmapLogic: false,
            realtimeSync: false
        };

        function log(message, elementId = 'heatmapTestLog') {
            const logElement = document.getElementById(elementId);
            const timestamp = new Date().toLocaleTimeString();
            logElement.innerHTML += `[${timestamp}] ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function updateStatus(elementId, status, message) {
            const element = document.getElementById(elementId);
            element.className = `status ${status}`;
            element.textContent = message;
        }

        async function testSystemConnection() {
            apiUrl = document.getElementById('apiUrl').value;
            
            try {
                updateStatus('connectionStatus', 'info', 'æ­£åœ¨æµ‹è¯•è¿æ¥...');
                
                // æµ‹è¯•APIè¿æ¥
                const healthResponse = await fetch(`${apiUrl}/health`);
                if (!healthResponse.ok) throw new Error('APIå¥åº·æ£€æŸ¥å¤±è´¥');
                
                // æµ‹è¯•äº‹ä»¶æ˜¯å¦å­˜åœ¨
                const eventResponse = await fetch(`${apiUrl}/events/${eventId}`);
                if (!eventResponse.ok) throw new Error('æµ‹è¯•äº‹ä»¶ä¸å­˜åœ¨');
                
                testResults.connection = true;
                updateStatus('connectionStatus', 'success', 'âœ… è¿æ¥æ­£å¸¸');
                log('ç³»ç»Ÿè¿æ¥æµ‹è¯•é€šè¿‡', 'heatmapTestLog');
                
            } catch (error) {
                testResults.connection = false;
                updateStatus('connectionStatus', 'error', `âŒ è¿æ¥å¤±è´¥: ${error.message}`);
                log(`ç³»ç»Ÿè¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'heatmapTestLog');
            }
        }

        async function testHeatmapLogic() {
            if (!testResults.connection) {
                alert('è¯·å…ˆæµ‹è¯•ç³»ç»Ÿè¿æ¥');
                return;
            }

            try {
                updateStatus('heatmapTestStatus', 'info', 'ğŸ§ª æ­£åœ¨æµ‹è¯•çƒ­åŠ›å›¾é€»è¾‘...');
                log('å¼€å§‹çƒ­åŠ›å›¾è®¡ç®—é€»è¾‘æµ‹è¯•', 'heatmapTestLog');

                // åˆ›å»ºä¸€ä¸ªæµ‹è¯•ç”¨æˆ·ï¼Œä½¿ç”¨å¯è¡Œæ—¶é—´æ¨¡å¼ï¼Œåªé€‰æ‹©ä¸€ä¸ªæ—¶é—´æ®µ
                const testUser = `æµ‹è¯•ç”¨æˆ·_çƒ­åŠ›å›¾_${Date.now()}`;
                const responseData = {
                    eventId: eventId,
                    participantName: testUser,
                    userInitials: testUser.substring(0, 2),
                    paintMode: 'available', // å…³é”®ï¼šå¯è¡Œæ—¶é—´æ¨¡å¼
                    timezone: 'Asia/Shanghai',
                    availableSlots: [
                        JSON.stringify({
                            date: "1/6",
                            time: "10:00",
                            type: "available",
                            dateIndex: 0,
                            timeIndex: 4
                        })
                    ]
                };

                log(`åˆ›å»ºæµ‹è¯•å“åº”: ${testUser}, æ¨¡å¼: ${responseData.paintMode}, é€‰æ‹©: 1ä¸ªæ—¶é—´æ®µ`, 'heatmapTestLog');

                const response = await fetch(`${apiUrl}/responses`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(responseData)
                });

                if (!response.ok) {
                    throw new Error(`åˆ›å»ºå“åº”å¤±è´¥: ${response.status}`);
                }

                const result = await response.json();
                log(`âœ… å“åº”åˆ›å»ºæˆåŠŸ: ${result.id}`, 'heatmapTestLog');

                // ç­‰å¾…ä¸€æ®µæ—¶é—´è®©æ•°æ®åŒæ­¥
                await new Promise(resolve => setTimeout(resolve, 2000));

                // è·å–äº‹ä»¶çš„æ‰€æœ‰å“åº”ï¼Œæ£€æŸ¥çƒ­åŠ›å›¾è®¡ç®—æ˜¯å¦æ­£ç¡®
                const responsesResponse = await fetch(`${apiUrl}/responses/event/${eventId}`);
                const responses = await responsesResponse.json();
                
                log(`è·å–åˆ° ${responses.length} ä¸ªå“åº”`, 'heatmapTestLog');

                // æŸ¥æ‰¾æˆ‘ä»¬åˆšåˆ›å»ºçš„å“åº”
                const ourResponse = responses.find(r => r.participantName === testUser);
                if (!ourResponse) {
                    throw new Error('æœªæ‰¾åˆ°åˆšåˆ›å»ºçš„å“åº”');
                }

                log(`éªŒè¯å“åº”æ•°æ®: æ¨¡å¼=${ourResponse.paintMode}, æ—¶é—´æ®µæ•°é‡=${ourResponse.availableSlots.length}`, 'heatmapTestLog');

                // éªŒè¯é€»è¾‘ï¼šå¯è¡Œæ—¶é—´æ¨¡å¼ä¸‹ï¼Œåªé€‰æ‹©1ä¸ªæ—¶é—´æ®µï¼Œåº”è¯¥åªæœ‰1ä¸ªæ—¶é—´æ®µè¢«æ ‡è®°ä¸ºå¯è¡Œ
                if (ourResponse.paintMode.toLowerCase() === 'available' && ourResponse.availableSlots.length === 1) {
                    testResults.heatmapLogic = true;
                    updateStatus('heatmapTestStatus', 'success', 'âœ… çƒ­åŠ›å›¾é€»è¾‘æµ‹è¯•é€šè¿‡');
                    log('âœ… çƒ­åŠ›å›¾è®¡ç®—é€»è¾‘æ­£ç¡®ï¼šå¯è¡Œæ—¶é—´æ¨¡å¼ä¸‹é€‰æ‹©1ä¸ªæ—¶é—´æ®µï¼Œæ­£ç¡®æ˜¾ç¤ºä¸º1ä¸ªå¯è¡Œæ—¶é—´æ®µ', 'heatmapTestLog');
                } else {
                    throw new Error('çƒ­åŠ›å›¾é€»è¾‘é”™è¯¯ï¼šå¯è¡Œæ—¶é—´æ¨¡å¼ä¸‹åº”è¯¥åªæœ‰é€‰ä¸­çš„æ—¶é—´æ®µè¢«æ ‡è®°ä¸ºå¯è¡Œ');
                }

            } catch (error) {
                testResults.heatmapLogic = false;
                updateStatus('heatmapTestStatus', 'error', `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);
                log(`âŒ çƒ­åŠ›å›¾é€»è¾‘æµ‹è¯•å¤±è´¥: ${error.message}`, 'heatmapTestLog');
            }
        }

        async function clearTestData() {
            try {
                log('å¼€å§‹æ¸…ç†æµ‹è¯•æ•°æ®...', 'heatmapTestLog');
                
                // è·å–æ‰€æœ‰å“åº”
                const responsesResponse = await fetch(`${apiUrl}/responses/event/${eventId}`);
                const responses = await responsesResponse.json();
                
                // åˆ é™¤æµ‹è¯•ç”¨æˆ·çš„å“åº”
                let deletedCount = 0;
                for (const response of responses) {
                    if (response.participantName.includes('æµ‹è¯•ç”¨æˆ·') || response.participantName.includes('User')) {
                        try {
                            await fetch(`${apiUrl}/responses/${response.id}`, {
                                method: 'DELETE'
                            });
                            deletedCount++;
                        } catch (error) {
                            log(`åˆ é™¤å“åº”å¤±è´¥: ${response.id}`, 'heatmapTestLog');
                        }
                    }
                }
                
                log(`âœ… æ¸…ç†å®Œæˆï¼Œåˆ é™¤äº† ${deletedCount} ä¸ªæµ‹è¯•å“åº”`, 'heatmapTestLog');
                
            } catch (error) {
                log(`âŒ æ¸…ç†å¤±è´¥: ${error.message}`, 'heatmapTestLog');
            }
        }

        let realtimeTestActive = false;
        let userSockets = {};

        async function startRealtimeTest() {
            if (!testResults.connection) {
                alert('è¯·å…ˆæµ‹è¯•ç³»ç»Ÿè¿æ¥');
                return;
            }

            realtimeTestActive = true;
            updateStatus('realtimeTestStatus', 'info', 'ğŸš€ å®æ—¶åŒæ­¥æµ‹è¯•è¿›è¡Œä¸­...');
            log('å¼€å§‹å®æ—¶åŒæ­¥æµ‹è¯•', 'realtimeTestLog');

            try {
                // æ¸…ç†ä¹‹å‰çš„æµ‹è¯•æ•°æ®
                await clearTestData();
                
                // æ¨¡æ‹Ÿä¸‰ä¸ªç”¨æˆ·è¿æ¥
                await simulateUserConnection('User1', 1);
                await simulateUserConnection('User2', 2);
                await simulateUserConnection('User3', 3);
                
                log('æ‰€æœ‰ç”¨æˆ·è¿æ¥å®Œæˆï¼Œå¼€å§‹æµ‹è¯•å®æ—¶åŒæ­¥...', 'realtimeTestLog');
                
                testResults.realtimeSync = true;
                updateStatus('realtimeTestStatus', 'success', 'âœ… å®æ—¶åŒæ­¥æµ‹è¯•å‡†å¤‡å®Œæˆ');
                
            } catch (error) {
                testResults.realtimeSync = false;
                updateStatus('realtimeTestStatus', 'error', `âŒ æµ‹è¯•å¤±è´¥: ${error.message}`);
                log(`âŒ å®æ—¶åŒæ­¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'realtimeTestLog');
            }
        }

        async function simulateUserConnection(userName, userNum) {
            try {
                updateStatus(`user${userNum}Status`, 'info', 'è¿æ¥ä¸­...');
                
                // è¿™é‡Œæˆ‘ä»¬ç®€åŒ–å¤„ç†ï¼Œç›´æ¥æµ‹è¯•APIè°ƒç”¨
                // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œä¼šå»ºç«‹WebSocketè¿æ¥
                
                updateStatus(`user${userNum}Status`, 'success', 'å·²è¿æ¥');
                log(`${userName} è¿æ¥æˆåŠŸ`, 'realtimeTestLog');
                
            } catch (error) {
                updateStatus(`user${userNum}Status`, 'error', 'è¿æ¥å¤±è´¥');
                log(`${userName} è¿æ¥å¤±è´¥: ${error.message}`, 'realtimeTestLog');
                throw error;
            }
        }

        async function simulateUser1Action() {
            await simulateUserAction('User1', 1, 0, 5); // é€‰æ‹©ç¬¬1å¤©ç¬¬6ä¸ªæ—¶é—´æ®µ
        }

        async function simulateUser2Action() {
            await simulateUserAction('User2', 2, 1, 8); // é€‰æ‹©ç¬¬2å¤©ç¬¬9ä¸ªæ—¶é—´æ®µ
        }

        async function simulateUser3Action() {
            await simulateUserAction('User3', 3, 0, 5); // é€‰æ‹©ç¬¬1å¤©ç¬¬6ä¸ªæ—¶é—´æ®µï¼ˆä¸User1é‡å ï¼‰
        }

        async function simulateUserAction(userName, userNum, dateIndex, timeIndex) {
            if (!realtimeTestActive) {
                alert('è¯·å…ˆå¼€å§‹å®æ—¶åŒæ­¥æµ‹è¯•');
                return;
            }

            try {
                log(`${userName} å¼€å§‹é€‰æ‹©æ—¶é—´æ®µ...`, 'realtimeTestLog');
                
                const responseData = {
                    eventId: eventId,
                    participantName: userName,
                    userInitials: userName.substring(0, 2),
                    paintMode: 'available',
                    timezone: 'Asia/Shanghai',
                    availableSlots: [
                        JSON.stringify({
                            date: `1/${6 + dateIndex}`,
                            time: `${9 + timeIndex}:00`,
                            type: "available",
                            dateIndex: dateIndex,
                            timeIndex: timeIndex
                        })
                    ]
                };

                const response = await fetch(`${apiUrl}/responses`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(responseData)
                });

                if (!response.ok) {
                    throw new Error(`åˆ›å»ºå“åº”å¤±è´¥: ${response.status}`);
                }

                const result = await response.json();
                log(`âœ… ${userName} æˆåŠŸé€‰æ‹©æ—¶é—´æ®µï¼Œå“åº”ID: ${result.id}`, 'realtimeTestLog');
                
                // æ¨¡æ‹Ÿæ£€æŸ¥å…¶ä»–ç”¨æˆ·æ˜¯å¦èƒ½ç«‹å³çœ‹åˆ°æ›´æ–°
                setTimeout(async () => {
                    await checkRealtimeSync(userName);
                }, 1000);
                
            } catch (error) {
                log(`âŒ ${userName} æ“ä½œå¤±è´¥: ${error.message}`, 'realtimeTestLog');
            }
        }

        async function checkRealtimeSync(triggerUser) {
            try {
                // è·å–æœ€æ–°çš„å“åº”æ•°æ®
                const responsesResponse = await fetch(`${apiUrl}/responses/event/${eventId}`);
                const responses = await responsesResponse.json();
                
                const userResponses = responses.filter(r => r.participantName.startsWith('User'));
                log(`å®æ—¶åŒæ­¥æ£€æŸ¥: å½“å‰æœ‰ ${userResponses.length} ä¸ªç”¨æˆ·å“åº”`, 'realtimeTestLog');
                
                if (userResponses.length > 1) {
                    log('âœ… å®æ—¶åŒæ­¥æ­£å¸¸ï¼šå¤šä¸ªç”¨æˆ·çš„é€‰æ‹©éƒ½èƒ½è¢«æ­£ç¡®è·å–', 'realtimeTestLog');
                }
                
            } catch (error) {
                log(`âŒ å®æ—¶åŒæ­¥æ£€æŸ¥å¤±è´¥: ${error.message}`, 'realtimeTestLog');
            }
        }

        function stopRealtimeTest() {
            realtimeTestActive = false;
            updateStatus('realtimeTestStatus', 'info', 'â¹ï¸ æµ‹è¯•å·²åœæ­¢');
            log('å®æ—¶åŒæ­¥æµ‹è¯•å·²åœæ­¢', 'realtimeTestLog');
            
            // é‡ç½®ç”¨æˆ·çŠ¶æ€
            updateStatus('user1Status', 'info', 'æœªè¿æ¥');
            updateStatus('user2Status', 'info', 'æœªè¿æ¥');
            updateStatus('user3Status', 'info', 'æœªè¿æ¥');
        }

        // å®šæœŸæ›´æ–°æµ‹è¯•ç»“æœæ±‡æ€»
        setInterval(() => {
            const summary = document.getElementById('testSummary');
            const passedTests = Object.values(testResults).filter(Boolean).length;
            const totalTests = Object.keys(testResults).length;
            
            let summaryText = `æµ‹è¯•è¿›åº¦: ${passedTests}/${totalTests} é¡¹é€šè¿‡\n\n`;
            summaryText += `ğŸ”— ç³»ç»Ÿè¿æ¥: ${testResults.connection ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}\n`;
            summaryText += `ğŸ”¥ çƒ­åŠ›å›¾é€»è¾‘: ${testResults.heatmapLogic ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}\n`;
            summaryText += `ğŸ“¡ å®æ—¶åŒæ­¥: ${testResults.realtimeSync ? 'âœ… é€šè¿‡' : 'âŒ å¤±è´¥'}\n\n`;
            
            if (passedTests === totalTests) {
                summaryText += 'ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼ä¿®å¤ç”Ÿæ•ˆã€‚';
            } else {
                summaryText += 'âš ï¸ è¿˜æœ‰æµ‹è¯•æœªé€šè¿‡ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥ã€‚';
            }
            
            summary.textContent = summaryText;
        }, 1000);

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æµ‹è¯•è¿æ¥
        window.onload = function() {
            setTimeout(testSystemConnection, 1000);
        };
    </script>
</body>
</html> 