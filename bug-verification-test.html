<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bugä¿®å¤éªŒè¯æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-container {
            background: white;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-header {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 20px;
            color: #333;
        }
        .controls {
            margin: 15px 0;
        }
        .controls button {
            margin: 5px;
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary {
            background: #007bff;
            color: white;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-warning {
            background: #ffc107;
            color: black;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.connected {
            background: #d4edda;
            color: #155724;
        }
        .status.disconnected {
            background: #f8d7da;
            color: #721c24;
        }
        .status.testing {
            background: #fff3cd;
            color: #856404;
        }
        .log-area {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
            font-family: monospace;
            max-height: 300px;
            overflow-y: auto;
        }
        .test-result {
            margin: 10px 0;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .test-result.pass {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }
        .test-result.fail {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }
        .test-result.pending {
            background: #fff3cd;
            border-color: #ffeaa7;
            color: #856404;
        }
        .input-group {
            margin: 10px 0;
        }
        .input-group label {
            display: inline-block;
            width: 120px;
            font-weight: bold;
        }
        .input-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        .grid-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .time-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin: 10px 0;
        }
        .time-slot {
            width: 40px;
            height: 30px;
            border: 1px solid #ddd;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .time-slot:hover {
            background: #e9ecef;
        }
        .time-slot.selected {
            background: #007bff;
            color: white;
        }
        .time-slot.heatmap-1 { background: rgba(0,123,255,0.2); }
        .time-slot.heatmap-2 { background: rgba(0,123,255,0.4); }
        .time-slot.heatmap-3 { background: rgba(0,123,255,0.6); }
        .time-slot.heatmap-4 { background: rgba(0,123,255,0.8); }
        .time-slot.heatmap-5 { background: rgba(0,123,255,1); color: white; }
    </style>
</head>
<body>
    <div class="test-header">ğŸ› Bugä¿®å¤éªŒè¯æµ‹è¯•</div>
    
    <!-- è¿æ¥çŠ¶æ€ -->
    <div class="test-container">
        <h3>è¿æ¥çŠ¶æ€</h3>
        <div id="connectionStatus" class="status disconnected">æœªè¿æ¥</div>
        <div class="controls">
            <button onclick="connect()" class="btn-primary">è¿æ¥WebSocket</button>
            <button onclick="disconnect()" class="btn-danger">æ–­å¼€è¿æ¥</button>
        </div>
    </div>

    <!-- æ´»åŠ¨è®¾ç½® -->
    <div class="test-container">
        <h3>æ´»åŠ¨è®¾ç½®</h3>
        <div class="input-group">
            <label>æ´»åŠ¨ä»£ç :</label>
            <input type="text" id="tcCode" value="TEST02" placeholder="è¾“å…¥æ´»åŠ¨ä»£ç ">
            <button onclick="generateCode()" class="btn-warning">ç”Ÿæˆæ–°ä»£ç </button>
        </div>
        <div class="input-group">
            <label>ç”¨æˆ·å:</label>
            <input type="text" id="userName" value="ç”¨æˆ·A" placeholder="è¾“å…¥ç”¨æˆ·å">
        </div>
        <div class="controls">
            <button onclick="joinEvent()" class="btn-success">åŠ å…¥æ´»åŠ¨</button>
            <button onclick="leaveEvent()" class="btn-danger">ç¦»å¼€æ´»åŠ¨</button>
        </div>
    </div>

    <!-- Bugæµ‹è¯•åŒºåŸŸ -->
    <div class="test-container">
        <h3>Bugæµ‹è¯•</h3>
        <div class="controls">
            <button onclick="testBug1()" class="btn-primary">æµ‹è¯•Bug #1 (å®æ—¶åŒæ­¥)</button>
            <button onclick="testBug2()" class="btn-primary">æµ‹è¯•Bug #2 (çŠ¶æ€æ¢å¤)</button>
            <button onclick="runAllTests()" class="btn-success">è¿è¡Œæ‰€æœ‰æµ‹è¯•</button>
            <button onclick="clearResults()" class="btn-warning">æ¸…ç©ºç»“æœ</button>
        </div>
        <div id="testResults"></div>
    </div>

    <!-- ç•Œé¢æ¨¡æ‹Ÿ -->
    <div class="test-container">
        <h3>ç•Œé¢æ¨¡æ‹Ÿ</h3>
        <div class="grid-container">
            <div>
                <h4>æˆ‘çš„æ—¶é—´é€‰æ‹©</h4>
                <div class="time-grid" id="userTimeSlots"></div>
                <div class="controls">
                    <button onclick="saveSelection()" class="btn-success">ä¿å­˜é€‰æ‹©</button>
                    <button onclick="clearSelection()" class="btn-danger">æ¸…ç©ºé€‰æ‹©</button>
                </div>
            </div>
            <div>
                <h4>å›¢é˜Ÿçƒ­åŠ›å›¾</h4>
                <div class="time-grid" id="heatmapSlots"></div>
                <div id="participantsList"></div>
            </div>
        </div>
    </div>

    <!-- æ—¥å¿—åŒºåŸŸ -->
    <div class="test-container">
        <h3>å®æ—¶æ—¥å¿—</h3>
        <div class="controls">
            <button onclick="clearLog()" class="btn-warning">æ¸…ç©ºæ—¥å¿—</button>
        </div>
        <div id="logArea" class="log-area"></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let client = null;
        let isConnected = false;
        let currentEvent = null;
        let currentUser = null;
        let userSelection = new Set();
        let testResults = {};

        // æ¨¡æ‹ŸWebSocketå®¢æˆ·ç«¯
        class SimpleWebSocketClient {
            constructor() {
                this.socket = null;
                this.handlers = {};
                this.isConnected = false;
            }

            async connect() {
                try {
                    // åŠ¨æ€å¯¼å…¥socket.io
                    const { io } = await import('https://cdn.socket.io/4.7.2/socket.io.esm.min.js');
                    
                    this.socket = io('http://localhost:3000', {
                        transports: ['websocket', 'polling']
                    });

                    return new Promise((resolve, reject) => {
                        this.socket.on('connect', () => {
                            this.isConnected = true;
                            log('WebSocketè¿æ¥æˆåŠŸ');
                            resolve();
                        });

                        this.socket.on('connect_error', (error) => {
                            log('è¿æ¥é”™è¯¯: ' + error.message);
                            reject(error);
                        });

                        this.socket.on('room-update', (data) => {
                            log('æ”¶åˆ°æˆ¿é—´æ›´æ–°: ' + JSON.stringify(data));
                            if (this.handlers.roomUpdate) {
                                this.handlers.roomUpdate(data);
                            }
                        });

                        this.socket.on('response-updated', (data) => {
                            log('æ”¶åˆ°å“åº”æ›´æ–°: ' + JSON.stringify(data));
                            if (this.handlers.responseUpdate) {
                                this.handlers.responseUpdate(data);
                            }
                        });

                        this.socket.on('user-joined', (data) => {
                            log('ç”¨æˆ·åŠ å…¥: ' + JSON.stringify(data));
                            if (this.handlers.userJoined) {
                                this.handlers.userJoined(data);
                            }
                        });

                        this.socket.on('user-left', (data) => {
                            log('ç”¨æˆ·ç¦»å¼€: ' + JSON.stringify(data));
                            if (this.handlers.userLeft) {
                                this.handlers.userLeft(data);
                            }
                        });
                    });
                } catch (error) {
                    log('è¿æ¥å¤±è´¥: ' + error.message);
                    throw error;
                }
            }

            disconnect() {
                if (this.socket) {
                    this.socket.disconnect();
                    this.socket = null;
                    this.isConnected = false;
                    log('WebSocketè¿æ¥å·²æ–­å¼€');
                }
            }

            joinEvent(eventId, userName) {
                if (!this.isConnected) {
                    throw new Error('WebSocketæœªè¿æ¥');
                }
                log(`åŠ å…¥æ´»åŠ¨: ${eventId}, ç”¨æˆ·: ${userName}`);
                this.socket.emit('join-event', { eventId, participantName: userName });
            }

            leaveEvent(eventId, userName) {
                if (!this.isConnected) {
                    return;
                }
                log(`ç¦»å¼€æ´»åŠ¨: ${eventId}, ç”¨æˆ·: ${userName}`);
                this.socket.emit('leave-event', { eventId, participantName: userName });
            }

            on(event, handler) {
                this.handlers[event] = handler;
            }
        }

        // APIå‡½æ•°
        async function apiCall(method, endpoint, data = null) {
            try {
                const options = {
                    method: method,
                    headers: {
                        'Content-Type': 'application/json',
                    }
                };

                if (data) {
                    options.body = JSON.stringify(data);
                }

                const response = await fetch(`http://localhost:3000/api${endpoint}`, options);
                const result = await response.json();

                if (!response.ok) {
                    throw new Error(result.message || `HTTP ${response.status}`);
                }

                return result;
            } catch (error) {
                log(`APIè°ƒç”¨å¤±è´¥: ${error.message}`);
                throw error;
            }
        }

        // è¿æ¥WebSocket
        async function connect() {
            try {
                updateStatus('testing', 'æ­£åœ¨è¿æ¥...');
                client = new SimpleWebSocketClient();
                
                client.on('roomUpdate', (data) => {
                    updateHeatmap(data.heatmap);
                    updateParticipants(data.participants);
                    updateTestResult('realtime-sync', true, 'å®æ—¶åŒæ­¥æ­£å¸¸å·¥ä½œ');
                });

                client.on('responseUpdate', (data) => {
                    updateHeatmap(data.heatmap);
                    updateTestResult('response-sync', true, 'å“åº”åŒæ­¥æ­£å¸¸');
                });

                await client.connect();
                isConnected = true;
                updateStatus('connected', 'å·²è¿æ¥');
                
            } catch (error) {
                updateStatus('disconnected', 'è¿æ¥å¤±è´¥: ' + error.message);
            }
        }

        // æ–­å¼€è¿æ¥
        function disconnect() {
            if (client) {
                client.disconnect();
                client = null;
            }
            isConnected = false;
            currentEvent = null;
            currentUser = null;
            updateStatus('disconnected', 'å·²æ–­å¼€è¿æ¥');
        }

        // ç”Ÿæˆæ´»åŠ¨ä»£ç 
        async function generateCode() {
            try {
                const result = await apiCall('GET', '/events/generate/tc-code');
                document.getElementById('tcCode').value = result.data.tcCode;
                log(`ç”Ÿæˆæ–°ä»£ç : ${result.data.tcCode}`);
            } catch (error) {
                log(`ç”Ÿæˆä»£ç å¤±è´¥: ${error.message}`);
            }
        }

        // åŠ å…¥æ´»åŠ¨
        async function joinEvent() {
            try {
                if (!isConnected) {
                    log('è¯·å…ˆè¿æ¥WebSocket');
                    return;
                }

                const tcCode = document.getElementById('tcCode').value;
                const userName = document.getElementById('userName').value;

                if (!tcCode || !userName) {
                    log('è¯·è¾“å…¥æ´»åŠ¨ä»£ç å’Œç”¨æˆ·å');
                    return;
                }

                // è·å–æ´»åŠ¨ä¿¡æ¯
                const eventResult = await apiCall('GET', `/events/tc/${tcCode}`);
                currentEvent = eventResult.data;
                currentUser = userName;

                // åŠ å…¥WebSocketæˆ¿é—´
                client.joinEvent(currentEvent.id, userName);

                // è·å–æˆ¿é—´æ•°æ®
                const roomResult = await apiCall('GET', `/responses/room/${currentEvent.id}`);
                updateHeatmap(roomResult.data.heatmap);
                updateParticipants(roomResult.data.participants);

                log(`æˆåŠŸåŠ å…¥æ´»åŠ¨: ${tcCode}`);
                updateTestResult('join-event', true, 'æˆåŠŸåŠ å…¥æ´»åŠ¨');

            } catch (error) {
                log(`åŠ å…¥æ´»åŠ¨å¤±è´¥: ${error.message}`);
                updateTestResult('join-event', false, 'åŠ å…¥æ´»åŠ¨å¤±è´¥');
            }
        }

        // ç¦»å¼€æ´»åŠ¨
        function leaveEvent() {
            if (client && currentEvent && currentUser) {
                client.leaveEvent(currentEvent.id, currentUser);
            }
            currentEvent = null;
            currentUser = null;
            clearHeatmap();
            clearParticipants();
            log('å·²ç¦»å¼€æ´»åŠ¨');
        }

        // ä¿å­˜é€‰æ‹©
        async function saveSelection() {
            try {
                if (!currentEvent || !currentUser) {
                    log('è¯·å…ˆåŠ å…¥æ´»åŠ¨');
                    return;
                }

                const availability = Array.from(userSelection).map(slotId => {
                    const [day, hour] = slotId.split('-').map(Number);
                    return { day, hour, available: true };
                });

                const result = await apiCall('POST', '/responses', {
                    eventId: currentEvent.id,
                    participantName: currentUser,
                    availability: availability,
                    paintMode: 'individual'
                });

                log('é€‰æ‹©ä¿å­˜æˆåŠŸ');
                updateTestResult('save-response', true, 'å“åº”ä¿å­˜æˆåŠŸ');

            } catch (error) {
                log(`ä¿å­˜å¤±è´¥: ${error.message}`);
                updateTestResult('save-response', false, 'ä¿å­˜å¤±è´¥');
            }
        }

        // æ¸…ç©ºé€‰æ‹©
        function clearSelection() {
            userSelection.clear();
            document.querySelectorAll('#userTimeSlots .time-slot').forEach(slot => {
                slot.classList.remove('selected');
            });
            log('é€‰æ‹©å·²æ¸…ç©º');
        }

        // æµ‹è¯•Bug #1
        async function testBug1() {
            log('=== å¼€å§‹æµ‹è¯•Bug #1: å®æ—¶åŒæ­¥ ===');
            updateTestResult('bug1-test', 'pending', 'æµ‹è¯•è¿›è¡Œä¸­...');

            try {
                // ç¡®ä¿å·²è¿æ¥å’ŒåŠ å…¥æ´»åŠ¨
                if (!isConnected || !currentEvent) {
                    throw new Error('è¯·å…ˆè¿æ¥å¹¶åŠ å…¥æ´»åŠ¨');
                }

                // æ¸…ç©ºå½“å‰é€‰æ‹©
                clearSelection();

                // é€‰æ‹©ä¸€ä¸ªæ—¶é—´æ®µ
                const testSlot = '0-0';
                userSelection.add(testSlot);
                document.getElementById(`user-${testSlot}`).classList.add('selected');

                // ä¿å­˜é€‰æ‹©
                await saveSelection();

                // ç­‰å¾…å®æ—¶åŒæ­¥
                let syncReceived = false;
                const originalRoomUpdate = client.handlers.roomUpdate;
                
                client.on('roomUpdate', (data) => {
                    syncReceived = true;
                    if (originalRoomUpdate) originalRoomUpdate(data);
                });

                // ç­‰å¾…2ç§’æ£€æŸ¥åŒæ­¥
                setTimeout(() => {
                    if (syncReceived || testResults['realtime-sync']) {
                        updateTestResult('bug1-test', true, 'âœ… Bug #1 å·²ä¿®å¤ - å®æ—¶åŒæ­¥æ­£å¸¸');
                        log('Bug #1 æµ‹è¯•é€šè¿‡');
                    } else {
                        updateTestResult('bug1-test', false, 'âŒ Bug #1 ä»å­˜åœ¨ - å®æ—¶åŒæ­¥å¤±è´¥');
                        log('Bug #1 æµ‹è¯•å¤±è´¥');
                    }
                }, 2000);

            } catch (error) {
                updateTestResult('bug1-test', false, `Bug #1 æµ‹è¯•å¤±è´¥: ${error.message}`);
                log(`Bug #1 æµ‹è¯•é”™è¯¯: ${error.message}`);
            }
        }

        // æµ‹è¯•Bug #2
        async function testBug2() {
            log('=== å¼€å§‹æµ‹è¯•Bug #2: çŠ¶æ€æ¢å¤ ===');
            updateTestResult('bug2-test', 'pending', 'æµ‹è¯•è¿›è¡Œä¸­...');

            try {
                // ç¡®ä¿å·²è¿æ¥å’ŒåŠ å…¥æ´»åŠ¨
                if (!isConnected || !currentEvent) {
                    throw new Error('è¯·å…ˆè¿æ¥å¹¶åŠ å…¥æ´»åŠ¨');
                }

                // ä¿å­˜ä¸€äº›é€‰æ‹©
                userSelection.add('1-1');
                userSelection.add('2-2');
                await saveSelection();

                // æ¨¡æ‹Ÿé¡µé¢åˆ·æ–° - æ¸…ç©ºæœ¬åœ°çŠ¶æ€
                const savedEvent = currentEvent;
                const savedUser = currentUser;
                
                clearSelection();
                clearHeatmap();
                
                log('æ¨¡æ‹Ÿé¡µé¢åˆ·æ–°...');

                // ç­‰å¾…ä¸€ä¸‹å†æ¢å¤çŠ¶æ€
                setTimeout(async () => {
                    try {
                        // é‡æ–°è·å–ç”¨æˆ·å“åº”
                        const userResult = await apiCall('GET', `/responses/user/${savedEvent.id}/${savedUser}`);
                        
                        if (userResult.data && userResult.data.availability) {
                            // æ¢å¤ç”¨æˆ·é€‰æ‹©
                            userSelection.clear();
                            userResult.data.availability.forEach(slot => {
                                if (slot.available) {
                                    const slotId = `${slot.day}-${slot.hour}`;
                                    userSelection.add(slotId);
                                    const element = document.getElementById(`user-${slotId}`);
                                    if (element) {
                                        element.classList.add('selected');
                                    }
                                }
                            });

                            // é‡æ–°è·å–æˆ¿é—´æ•°æ®
                            const roomResult = await apiCall('GET', `/responses/room/${savedEvent.id}`);
                            updateHeatmap(roomResult.data.heatmap);
                            updateParticipants(roomResult.data.participants);

                            updateTestResult('bug2-test', true, 'âœ… Bug #2 å·²ä¿®å¤ - çŠ¶æ€æ¢å¤æ­£å¸¸');
                            log('Bug #2 æµ‹è¯•é€šè¿‡ - çŠ¶æ€æ¢å¤æˆåŠŸ');
                        } else {
                            updateTestResult('bug2-test', false, 'âŒ Bug #2 ä»å­˜åœ¨ - æ— æ³•æ¢å¤çŠ¶æ€');
                            log('Bug #2 æµ‹è¯•å¤±è´¥ - çŠ¶æ€æ¢å¤å¤±è´¥');
                        }
                    } catch (error) {
                        updateTestResult('bug2-test', false, `Bug #2 æµ‹è¯•å¤±è´¥: ${error.message}`);
                        log(`Bug #2 æµ‹è¯•é”™è¯¯: ${error.message}`);
                    }
                }, 1000);

            } catch (error) {
                updateTestResult('bug2-test', false, `Bug #2 æµ‹è¯•å¤±è´¥: ${error.message}`);
                log(`Bug #2 æµ‹è¯•é”™è¯¯: ${error.message}`);
            }
        }

        // è¿è¡Œæ‰€æœ‰æµ‹è¯•
        async function runAllTests() {
            log('=== å¼€å§‹è¿è¡Œæ‰€æœ‰æµ‹è¯• ===');
            
            // æ¸…ç©ºä¹‹å‰çš„ç»“æœ
            testResults = {};
            
            // æŒ‰é¡ºåºè¿è¡Œæµ‹è¯•
            await testBug1();
            
            setTimeout(async () => {
                await testBug2();
                
                setTimeout(() => {
                    log('=== æ‰€æœ‰æµ‹è¯•å®Œæˆ ===');
                    showTestSummary();
                }, 3000);
            }, 3000);
        }

        // æ˜¾ç¤ºæµ‹è¯•æ‘˜è¦
        function showTestSummary() {
            const passed = Object.values(testResults).filter(r => r === true).length;
            const total = Object.keys(testResults).length;
            
            log(`æµ‹è¯•æ‘˜è¦: ${passed}/${total} é¡¹æµ‹è¯•é€šè¿‡`);
            
            if (passed === total) {
                log('ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼Bugå·²ä¿®å¤ï¼');
            } else {
                log('âš ï¸ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æŸ¥');
            }
        }

        // åˆå§‹åŒ–æ—¶é—´ç½‘æ ¼
        function initializeTimeSlots() {
            const days = ['å‘¨ä¸€', 'å‘¨äºŒ', 'å‘¨ä¸‰', 'å‘¨å››', 'å‘¨äº”', 'å‘¨å…­', 'å‘¨æ—¥'];
            const hours = ['09', '10', '11', '14', '15', '16', '17'];
            
            const userSlots = document.getElementById('userTimeSlots');
            const heatmapSlots = document.getElementById('heatmapSlots');
            
            userSlots.innerHTML = '';
            heatmapSlots.innerHTML = '';
            
            days.forEach((day, dayIndex) => {
                hours.forEach((hour, hourIndex) => {
                    const slotId = `${dayIndex}-${hourIndex}`;
                    
                    // ç”¨æˆ·é€‰æ‹©åŒºåŸŸ
                    const userSlot = document.createElement('div');
                    userSlot.className = 'time-slot';
                    userSlot.id = `user-${slotId}`;
                    userSlot.textContent = hour;
                    userSlot.title = `${day} ${hour}:00`;
                    userSlot.onclick = () => {
                        if (userSelection.has(slotId)) {
                            userSelection.delete(slotId);
                            userSlot.classList.remove('selected');
                        } else {
                            userSelection.add(slotId);
                            userSlot.classList.add('selected');
                        }
                    };
                    userSlots.appendChild(userSlot);
                    
                    // çƒ­åŠ›å›¾åŒºåŸŸ
                    const heatmapSlot = document.createElement('div');
                    heatmapSlot.className = 'time-slot';
                    heatmapSlot.id = `heatmap-${slotId}`;
                    heatmapSlot.textContent = hour;
                    heatmapSlot.title = `${day} ${hour}:00`;
                    heatmapSlots.appendChild(heatmapSlot);
                });
            });
        }

        // æ›´æ–°çƒ­åŠ›å›¾
        function updateHeatmap(heatmapData) {
            if (!heatmapData) return;
            
            // æ¸…é™¤ç°æœ‰æ ·å¼
            clearHeatmap();
            
            heatmapData.forEach(slot => {
                const slotId = `${slot.day}-${slot.hour}`;
                const element = document.getElementById(`heatmap-${slotId}`);
                if (element && slot.count > 0) {
                    const level = Math.min(5, slot.count);
                    element.classList.add(`heatmap-${level}`);
                    element.title = `${element.title} - ${slot.count} äºº`;
                }
            });
            
            log(`çƒ­åŠ›å›¾æ›´æ–°: ${heatmapData.length} ä¸ªæ—¶é—´æ®µ`);
        }

        // æ¸…ç©ºçƒ­åŠ›å›¾
        function clearHeatmap() {
            document.querySelectorAll('#heatmapSlots .time-slot').forEach(slot => {
                slot.className = 'time-slot';
            });
        }

        // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
        function updateParticipants(participants) {
            const container = document.getElementById('participantsList');
            
            if (!participants || participants.length === 0) {
                container.innerHTML = '<div>æš‚æ— å‚ä¸è€…</div>';
                return;
            }
            
            container.innerHTML = '<h5>å‚ä¸è€…:</h5>' + 
                participants.map(p => `<div>${p.name} (${p.hasResponse ? 'å·²å“åº”' : 'æœªå“åº”'})</div>`).join('');
        }

        // æ¸…ç©ºå‚ä¸è€…
        function clearParticipants() {
            document.getElementById('participantsList').innerHTML = '';
        }

        // æ›´æ–°çŠ¶æ€
        function updateStatus(status, message) {
            const statusDiv = document.getElementById('connectionStatus');
            statusDiv.className = `status ${status}`;
            statusDiv.textContent = message;
        }

        // æ›´æ–°æµ‹è¯•ç»“æœ
        function updateTestResult(testId, status, message) {
            testResults[testId] = status;
            
            const container = document.getElementById('testResults');
            const existing = document.getElementById(`test-${testId}`);
            
            const statusClass = status === true ? 'pass' : status === false ? 'fail' : 'pending';
            const statusIcon = status === true ? 'âœ…' : status === false ? 'âŒ' : 'â³';
            
            const html = `
                <div class="test-result ${statusClass}" id="test-${testId}">
                    <strong>${statusIcon} ${testId}</strong>: ${message}
                </div>
            `;
            
            if (existing) {
                existing.outerHTML = html;
            } else {
                container.insertAdjacentHTML('beforeend', html);
            }
        }

        // æ¸…ç©ºæµ‹è¯•ç»“æœ
        function clearResults() {
            document.getElementById('testResults').innerHTML = '';
            testResults = {};
            log('æµ‹è¯•ç»“æœå·²æ¸…ç©º');
        }

        // æ—¥å¿—å‡½æ•°
        function log(message) {
            const logArea = document.getElementById('logArea');
            const timestamp = new Date().toLocaleTimeString();
            logArea.innerHTML += `<div>[${timestamp}] ${message}</div>`;
            logArea.scrollTop = logArea.scrollHeight;
        }

        // æ¸…ç©ºæ—¥å¿—
        function clearLog() {
            document.getElementById('logArea').innerHTML = '';
        }

        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initializeTimeSlots();
            log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å¼€å§‹æµ‹è¯•');
        });

        // é¡µé¢å¸è½½æ—¶æ¸…ç†
        window.addEventListener('beforeunload', function() {
            disconnect();
        });
    </script>
</body>
</html> 