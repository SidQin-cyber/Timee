<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ–°æ¶æ„æµ‹è¯• - Bugä¿®å¤éªŒè¯</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            color: #333;
        }
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 2px solid #e0e0e0;
            border-radius: 15px;
            background: #fafafa;
        }
        .test-section h2 {
            color: #444;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .status {
            padding: 5px 10px;
            border-radius: 15px;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        .status.success { background: #4CAF50; }
        .status.error { background: #f44336; }
        .status.warning { background: #ff9800; }
        .status.info { background: #2196F3; }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        .panel {
            background: white;
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #ddd;
        }
        .panel h3 {
            color: #555;
            margin-bottom: 15px;
            border-bottom: 2px solid #eee;
            padding-bottom: 10px;
        }
        .button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        .button:hover {
            background: #5a6fd8;
            transform: translateY(-2px);
        }
        .button.secondary {
            background: #6c757d;
        }
        .button.danger {
            background: #dc3545;
        }
        .button.success {
            background: #28a745;
        }
        .input-group {
            margin-bottom: 15px;
        }
        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #555;
            font-weight: bold;
        }
        .input-group input, .input-group textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }
        .log {
            background: #1e1e1e;
            color: #00ff00;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 15px;
        }
        .heatmap {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 5px;
            margin-top: 15px;
        }
        .time-slot {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px 4px;
            text-align: center;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .time-slot.available {
            background: #4CAF50;
            color: white;
        }
        .time-slot.occupied {
            background: #ff9800;
            color: white;
        }
        .time-slot.conflict {
            background: #f44336;
            color: white;
        }
        .participant-list {
            margin-top: 15px;
        }
        .participant {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            margin-bottom: 5px;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #667eea;
        }
        .participant.online {
            border-left-color: #28a745;
        }
        .participant-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .avatar {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: #667eea;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 12px;
        }
        .websocket-status {
            padding: 8px 15px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            display: inline-block;
        }
        .websocket-status.connected {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .websocket-status.disconnected {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .websocket-status.connecting {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”§ æ–°æ¶æ„æµ‹è¯• - Bugä¿®å¤éªŒè¯</h1>
            <p>æµ‹è¯•æ–°çš„åç«¯æ¶æ„æ˜¯å¦è§£å†³äº†åŒç”¨æˆ·å®æ—¶åŒæ­¥å’ŒçŠ¶æ€æ¢å¤é—®é¢˜</p>
            <div id="websocket-status" class="websocket-status disconnected">WebSocket: æœªè¿æ¥</div>
        </div>

        <!-- Bug #1 æµ‹è¯•ï¼šåŒç”¨æˆ·å®æ—¶åŒæ­¥ -->
        <div class="test-section">
            <h2>
                ğŸ”„ Bug #1 æµ‹è¯•ï¼šåŒç”¨æˆ·å®æ—¶åŒæ­¥
                <span id="sync-status" class="status info">å¾…æµ‹è¯•</span>
            </h2>
            <p><strong>æµ‹è¯•ç›®æ ‡ï¼š</strong>éªŒè¯ç”¨æˆ·Açš„æ“ä½œèƒ½å¦ç«‹å³åœ¨ç”¨æˆ·Bçš„ç•Œé¢ä¸­åŒæ­¥æ˜¾ç¤ºï¼Œä¸éœ€è¦ç­‰å¾…ç”¨æˆ·ç¦»å¼€æˆ–åˆ·æ–°ã€‚</p>
            
            <div class="grid">
                <!-- å·¦ä¾§ï¼šç”¨æˆ·æ“ä½œé¢æ¿ -->
                <div class="panel">
                    <h3>ğŸ‘¤ ç”¨æˆ·æ“ä½œé¢æ¿</h3>
                    <div class="input-group">
                        <label>äº‹ä»¶ä»£ç  (T-Code)</label>
                        <input type="text" id="tcCode" value="TEST01" placeholder="è¾“å…¥äº‹ä»¶ä»£ç ">
                    </div>
                    <div class="input-group">
                        <label>ç”¨æˆ·å</label>
                        <input type="text" id="userName" value="TestUser" placeholder="è¾“å…¥ç”¨æˆ·å">
                    </div>
                    <div class="input-group">
                        <label>ç”¨æˆ·é‚®ç®±</label>
                        <input type="email" id="userEmail" value="test@example.com" placeholder="è¾“å…¥é‚®ç®±">
                    </div>
                    
                    <button class="button" onclick="joinRoom()">ğŸšª åŠ å…¥æˆ¿é—´</button>
                    <button class="button secondary" onclick="leaveRoom()">ğŸšª ç¦»å¼€æˆ¿é—´</button>
                    <button class="button success" onclick="submitResponse()">âœ… æäº¤æ—¶é—´é€‰æ‹©</button>
                    <button class="button danger" onclick="clearResponse()">ğŸ—‘ï¸ æ¸…é™¤é€‰æ‹©</button>
                    
                    <h4 style="margin-top: 20px;">æˆ‘çš„æ—¶é—´é€‰æ‹©</h4>
                    <div id="myTimeSlots" class="heatmap">
                        <!-- æ—¶é—´æ®µå°†é€šè¿‡ JavaScript ç”Ÿæˆ -->
                    </div>
                </div>

                <!-- å³ä¾§ï¼šå®æ—¶çƒ­åŠ›å›¾ -->
                <div class="panel">
                    <h3>ğŸ”¥ å®æ—¶çƒ­åŠ›å›¾ (åº”ç«‹å³æ›´æ–°)</h3>
                    <p>å½“å…¶ä»–ç”¨æˆ·æ“ä½œæ—¶ï¼Œè¿™é‡Œåº”è¯¥<strong>ç«‹å³</strong>æ˜¾ç¤ºæ›´æ–°ï¼Œæ— éœ€åˆ·æ–°é¡µé¢ã€‚</p>
                    
                    <div id="heatmap" class="heatmap">
                        <!-- çƒ­åŠ›å›¾å°†é€šè¿‡ JavaScript ç”Ÿæˆ -->
                    </div>
                    
                    <div class="participant-list">
                        <h4>åœ¨çº¿å‚ä¸è€…</h4>
                        <div id="participants">
                            <!-- å‚ä¸è€…åˆ—è¡¨å°†é€šè¿‡ JavaScript ç”Ÿæˆ -->
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bug #2 æµ‹è¯•ï¼šçŠ¶æ€æ¢å¤ -->
        <div class="test-section">
            <h2>
                ğŸ”„ Bug #2 æµ‹è¯•ï¼šçŠ¶æ€æ¢å¤
                <span id="recovery-status" class="status info">å¾…æµ‹è¯•</span>
            </h2>
            <p><strong>æµ‹è¯•ç›®æ ‡ï¼š</strong>éªŒè¯é¡µé¢åˆ·æ–°æˆ–é‡æ–°è¿›å…¥æˆ¿é—´åï¼Œç”¨æˆ·çš„ä¸ªäººçŠ¶æ€èƒ½å¦æ­£ç¡®æ¢å¤ï¼Œä¸”ä¸ä¼šæŸåçƒ­åŠ›å›¾ã€‚</p>
            
            <div class="grid">
                <div class="panel">
                    <h3>ğŸ’¾ çŠ¶æ€æ¢å¤æµ‹è¯•</h3>
                    <button class="button" onclick="saveCurrentState()">ğŸ’¾ ä¿å­˜å½“å‰çŠ¶æ€</button>
                    <button class="button secondary" onclick="simulateRefresh()">ğŸ”„ æ¨¡æ‹Ÿé¡µé¢åˆ·æ–°</button>
                    <button class="button success" onclick="recoverState()">ğŸ“¥ æ¢å¤ä¸ªäººçŠ¶æ€</button>
                    <button class="button" onclick="validateRoomData()">âœ… éªŒè¯æˆ¿é—´æ•°æ®</button>
                </div>
                
                <div class="panel">
                    <h3>ğŸ“Š çŠ¶æ€å¯¹æ¯”</h3>
                    <div id="stateComparison">
                        <div><strong>åˆ·æ–°å‰çŠ¶æ€ï¼š</strong><span id="stateBefore">æœªä¿å­˜</span></div>
                        <div><strong>åˆ·æ–°åçŠ¶æ€ï¼š</strong><span id="stateAfter">æœªæ¢å¤</span></div>
                        <div><strong>çŠ¶æ€åŒ¹é…ï¼š</strong><span id="stateMatch">-</span></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- å®æ—¶æ—¥å¿— -->
        <div class="test-section">
            <h2>ğŸ“ å®æ—¶æ—¥å¿—</h2>
            <div id="log" class="log">
                === æ–°æ¶æ„æµ‹è¯•æ—¥å¿— ===\n
                å‡†å¤‡å¼€å§‹æµ‹è¯•...\n
            </div>
            <button class="button secondary" onclick="clearLog()">ğŸ—‘ï¸ æ¸…é™¤æ—¥å¿—</button>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.0/socket.io.min.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let socket = null;
        let currentEventId = null;
        let currentUserName = null;
        let mySelectedSlots = new Set();
        let savedState = null;
        
        const API_BASE = 'http://localhost:3000/api';
        const WS_URL = 'http://localhost:3000';

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            generateTimeSlots();
            log('é¡µé¢å·²åŠ è½½ï¼Œå‡†å¤‡å¼€å§‹æµ‹è¯•');
        });

        // æ—¥å¿—å‡½æ•°
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logDiv = document.getElementById('log');
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'ğŸ“';
            logDiv.innerHTML += `[${timestamp}] ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '=== æ—¥å¿—å·²æ¸…é™¤ ===\n';
        }

        // ç”Ÿæˆæ—¶é—´æ®µ
        function generateTimeSlots() {
            const times = [
                '09:00', '10:00', '11:00', '12:00', '13:00', '14:00',
                '15:00', '16:00', '17:00', '18:00', '19:00', '20:00'
            ];
            
            const mySlots = document.getElementById('myTimeSlots');
            const heatmap = document.getElementById('heatmap');
            
            mySlots.innerHTML = '';
            heatmap.innerHTML = '';
            
            times.forEach(time => {
                // æˆ‘çš„æ—¶é—´é€‰æ‹©
                const mySlot = document.createElement('div');
                mySlot.className = 'time-slot';
                mySlot.textContent = time;
                mySlot.dataset.time = time;
                mySlot.onclick = () => toggleMySlot(time);
                mySlots.appendChild(mySlot);
                
                // çƒ­åŠ›å›¾
                const heatSlot = document.createElement('div');
                heatSlot.className = 'time-slot';
                heatSlot.textContent = time;
                heatSlot.dataset.time = time;
                heatSlot.dataset.count = '0';
                heatmap.appendChild(heatSlot);
            });
        }

        // åˆ‡æ¢æˆ‘çš„æ—¶é—´é€‰æ‹©
        function toggleMySlot(time) {
            const slot = document.querySelector(`#myTimeSlots .time-slot[data-time="${time}"]`);
            if (mySelectedSlots.has(time)) {
                mySelectedSlots.delete(time);
                slot.classList.remove('available');
                log(`å–æ¶ˆé€‰æ‹©æ—¶é—´ï¼š${time}`);
            } else {
                mySelectedSlots.add(time);
                slot.classList.add('available');
                log(`é€‰æ‹©æ—¶é—´ï¼š${time}`);
            }
        }

        // WebSocket è¿æ¥
        function connectWebSocket() {
            if (socket) {
                socket.disconnect();
            }
            
            updateWebSocketStatus('connecting');
            log('æ­£åœ¨è¿æ¥ WebSocket...');
            
            socket = io(WS_URL, {
                transports: ['websocket', 'polling']
            });

            socket.on('connect', () => {
                updateWebSocketStatus('connected');
                log('WebSocket è¿æ¥æˆåŠŸ', 'success');
            });

            socket.on('disconnect', () => {
                updateWebSocketStatus('disconnected');
                log('WebSocket è¿æ¥æ–­å¼€', 'warning');
            });

            socket.on('error', (error) => {
                log(`WebSocket é”™è¯¯ï¼š${error}`, 'error');
            });

            // ç›‘å¬å®æ—¶æ›´æ–°äº‹ä»¶
            socket.on('response_updated', (data) => {
                log('æ”¶åˆ°å“åº”æ›´æ–°é€šçŸ¥ï¼š' + JSON.stringify(data), 'success');
                updateSyncStatus('success');
                if (data.roomData) {
                    updateHeatmap(data.roomData.heatmapData);
                    updateParticipants(data.roomData.participants);
                }
            });

            socket.on('response_created', (data) => {
                log('æ”¶åˆ°å“åº”åˆ›å»ºé€šçŸ¥ï¼š' + JSON.stringify(data), 'success');
                updateSyncStatus('success');
            });

            socket.on('user-joined', (data) => {
                log(`ç”¨æˆ· ${data.participantName} åŠ å…¥äº†æˆ¿é—´`, 'info');
            });

            socket.on('user-left', (data) => {
                log(`ç”¨æˆ· ${data.participantName} ç¦»å¼€äº†æˆ¿é—´`, 'info');
            });
        }

        function updateWebSocketStatus(status) {
            const statusDiv = document.getElementById('websocket-status');
            statusDiv.className = `websocket-status ${status}`;
            statusDiv.textContent = `WebSocket: ${status === 'connected' ? 'å·²è¿æ¥' : status === 'connecting' ? 'è¿æ¥ä¸­' : 'æœªè¿æ¥'}`;
        }

        function updateSyncStatus(status) {
            const statusSpan = document.getElementById('sync-status');
            statusSpan.className = `status ${status}`;
            statusSpan.textContent = status === 'success' ? 'âœ… åŒæ­¥æ­£å¸¸' : status === 'error' ? 'âŒ åŒæ­¥å¤±è´¥' : 'â³ æµ‹è¯•ä¸­';
        }

        // åŠ å…¥æˆ¿é—´
        async function joinRoom() {
            const tcCode = document.getElementById('tcCode').value;
            const userName = document.getElementById('userName').value;
            
            if (!tcCode || !userName) {
                log('è¯·è¾“å…¥äº‹ä»¶ä»£ç å’Œç”¨æˆ·å', 'error');
                return;
            }

            try {
                // é¦–å…ˆè·å–äº‹ä»¶ä¿¡æ¯
                const eventResponse = await fetch(`${API_BASE}/events/tc/${tcCode}`);
                if (!eventResponse.ok) {
                    throw new Error('äº‹ä»¶ä¸å­˜åœ¨');
                }
                
                const eventData = await eventResponse.json();
                currentEventId = eventData.data.id;
                currentUserName = userName;
                
                log(`æ‰¾åˆ°äº‹ä»¶ï¼š${eventData.data.title} (ID: ${currentEventId})`);
                
                // è¿æ¥ WebSocket
                if (!socket) {
                    connectWebSocket();
                }
                
                // åŠ å…¥æˆ¿é—´
                socket.emit('join-event', {
                    eventId: currentEventId,
                    participantName: userName
                });
                
                log(`æ­£åœ¨åŠ å…¥æˆ¿é—´... äº‹ä»¶ï¼š${tcCode}ï¼Œç”¨æˆ·ï¼š${userName}`);
                
                // è·å–æˆ¿é—´æ•°æ®
                await loadRoomData();
                
                // å°è¯•æ¢å¤ç”¨æˆ·çŠ¶æ€
                await loadUserState();
                
            } catch (error) {
                log(`åŠ å…¥æˆ¿é—´å¤±è´¥ï¼š${error.message}`, 'error');
            }
        }

        // ç¦»å¼€æˆ¿é—´
        function leaveRoom() {
            if (socket && currentEventId) {
                socket.emit('leave-event', currentEventId);
                log('å·²ç¦»å¼€æˆ¿é—´');
            }
            currentEventId = null;
            currentUserName = null;
        }

        // åŠ è½½æˆ¿é—´æ•°æ®
        async function loadRoomData() {
            if (!currentEventId) return;
            
            try {
                const response = await fetch(`${API_BASE}/responses/room/${currentEventId}`);
                const data = await response.json();
                
                if (data.success) {
                    log(`åŠ è½½æˆ¿é—´æ•°æ®æˆåŠŸï¼Œå‚ä¸è€…ï¼š${data.data.participantCount}ï¼Œå“åº”ï¼š${data.data.responseCount}`);
                    updateHeatmap(data.data.heatmapData);
                    updateParticipants(data.data.participants);
                } else {
                    throw new Error(data.message);
                }
            } catch (error) {
                log(`åŠ è½½æˆ¿é—´æ•°æ®å¤±è´¥ï¼š${error.message}`, 'error');
            }
        }

        // åŠ è½½ç”¨æˆ·çŠ¶æ€
        async function loadUserState() {
            if (!currentEventId || !currentUserName) return;
            
            try {
                const response = await fetch(`${API_BASE}/responses/user/${currentEventId}/${currentUserName}`);
                const data = await response.json();
                
                if (data.success && data.data && data.data.response) {
                    const availability = data.data.response.availability;
                    log(`æ¢å¤ç”¨æˆ·çŠ¶æ€ï¼š${availability.length} ä¸ªæ—¶é—´æ®µ`);
                    
                    // æ¸…é™¤å½“å‰é€‰æ‹©
                    mySelectedSlots.clear();
                    document.querySelectorAll('#myTimeSlots .time-slot').forEach(slot => {
                        slot.classList.remove('available');
                    });
                    
                    // æ¢å¤é€‰æ‹©
                    availability.forEach(slot => {
                        if (slot.time) {
                            mySelectedSlots.add(slot.time);
                            const slotElement = document.querySelector(`#myTimeSlots .time-slot[data-time="${slot.time}"]`);
                            if (slotElement) {
                                slotElement.classList.add('available');
                            }
                        }
                    });
                    
                    updateRecoveryStatus('success');
                } else {
                    log('ç”¨æˆ·æš‚æ— ä¿å­˜çš„çŠ¶æ€');
                }
            } catch (error) {
                log(`åŠ è½½ç”¨æˆ·çŠ¶æ€å¤±è´¥ï¼š${error.message}`, 'error');
                updateRecoveryStatus('error');
            }
        }

        // æäº¤å“åº”
        async function submitResponse() {
            if (!currentEventId || !currentUserName) {
                log('è¯·å…ˆåŠ å…¥æˆ¿é—´', 'error');
                return;
            }
            
            if (mySelectedSlots.size === 0) {
                log('è¯·å…ˆé€‰æ‹©æ—¶é—´æ®µ', 'error');
                return;
            }
            
            try {
                const availability = Array.from(mySelectedSlots).map(time => ({
                    date: '2025-07-07',
                    time: time
                }));
                
                const response = await fetch(`${API_BASE}/responses`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        eventId: currentEventId,
                        participantName: currentUserName,
                        participantEmail: document.getElementById('userEmail').value,
                        userInitials: currentUserName.charAt(0).toUpperCase(),
                        timezone: 'Asia/Shanghai',
                        availability: availability,
                        paintMode: 'available'
                    })
                });
                
                const data = await response.json();
                if (data.success) {
                    log(`æäº¤å“åº”æˆåŠŸï¼Œé€‰æ‹©äº† ${availability.length} ä¸ªæ—¶é—´æ®µ`, 'success');
                    // æ³¨æ„ï¼šå®æ—¶æ›´æ–°åº”è¯¥é€šè¿‡ WebSocket è‡ªåŠ¨åˆ°æ¥
                } else {
                    throw new Error(data.message);
                }
            } catch (error) {
                log(`æäº¤å“åº”å¤±è´¥ï¼š${error.message}`, 'error');
            }
        }

        // æ¸…é™¤å“åº”
        function clearResponse() {
            mySelectedSlots.clear();
            document.querySelectorAll('#myTimeSlots .time-slot').forEach(slot => {
                slot.classList.remove('available');
            });
            log('å·²æ¸…é™¤æ‰€æœ‰æ—¶é—´é€‰æ‹©');
        }

        // æ›´æ–°çƒ­åŠ›å›¾
        function updateHeatmap(heatmapData) {
            const heatmap = document.getElementById('heatmap');
            const slots = heatmap.querySelectorAll('.time-slot');
            
            // é‡ç½®æ‰€æœ‰slots
            slots.forEach(slot => {
                slot.className = 'time-slot';
                slot.dataset.count = '0';
            });
            
            // æ›´æ–°æ•°æ®
            heatmapData.forEach(data => {
                const [date, time] = data.slot.split('_');
                const slot = heatmap.querySelector(`[data-time="${time}"]`);
                if (slot) {
                    slot.dataset.count = data.count;
                    if (data.count > 0) {
                        slot.classList.add('occupied');
                        slot.textContent = `${time}\n(${data.count})`;
                    }
                }
            });
            
            log(`çƒ­åŠ›å›¾å·²æ›´æ–°ï¼ŒåŒ…å« ${heatmapData.length} ä¸ªæ•°æ®ç‚¹`);
        }

        // æ›´æ–°å‚ä¸è€…åˆ—è¡¨
        function updateParticipants(participants) {
            const container = document.getElementById('participants');
            container.innerHTML = '';
            
            participants.forEach(participant => {
                const div = document.createElement('div');
                div.className = `participant ${participant.hasResponse ? 'online' : ''}`;
                div.innerHTML = `
                    <div class="participant-info">
                        <div class="avatar">${participant.initials || participant.name.charAt(0)}</div>
                        <span>${participant.name}</span>
                        ${participant.hasResponse ? '<span class="status success">å·²å“åº”</span>' : '<span class="status warning">æœªå“åº”</span>'}
                    </div>
                `;
                container.appendChild(div);
            });
            
            log(`å‚ä¸è€…åˆ—è¡¨å·²æ›´æ–°ï¼Œå…± ${participants.length} äºº`);
        }

        // Bug #2 æµ‹è¯•åŠŸèƒ½
        function saveCurrentState() {
            savedState = {
                selectedSlots: Array.from(mySelectedSlots),
                eventId: currentEventId,
                userName: currentUserName,
                timestamp: Date.now()
            };
            document.getElementById('stateBefore').textContent = `å·²ä¿å­˜ (${savedState.selectedSlots.length} ä¸ªæ—¶é—´æ®µ)`;
            log(`ä¿å­˜å½“å‰çŠ¶æ€ï¼š${savedState.selectedSlots.length} ä¸ªæ—¶é—´æ®µ`, 'success');
        }

        function simulateRefresh() {
            // æ¨¡æ‹Ÿé¡µé¢åˆ·æ–° - æ¸…é™¤å®¢æˆ·ç«¯çŠ¶æ€ä½†ä¿æŒæœåŠ¡å™¨æ•°æ®
            mySelectedSlots.clear();
            document.querySelectorAll('#myTimeSlots .time-slot').forEach(slot => {
                slot.classList.remove('available');
            });
            document.getElementById('heatmap').innerHTML = '';
            document.getElementById('participants').innerHTML = '';
            
            // æ–­å¼€ WebSocket
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            updateWebSocketStatus('disconnected');
            
            log('å·²æ¨¡æ‹Ÿé¡µé¢åˆ·æ–°ï¼Œå®¢æˆ·ç«¯çŠ¶æ€å·²æ¸…é™¤', 'warning');
        }

        async function recoverState() {
            if (!savedState) {
                log('æ²¡æœ‰ä¿å­˜çš„çŠ¶æ€å¯æ¢å¤', 'error');
                return;
            }
            
            // é‡æ–°è¿æ¥
            currentEventId = savedState.eventId;
            currentUserName = savedState.userName;
            document.getElementById('tcCode').value = 'TEST01';
            document.getElementById('userName').value = savedState.userName;
            
            await joinRoom();
            
            // éªŒè¯çŠ¶æ€æ¢å¤
            setTimeout(() => {
                const recoveredSlots = Array.from(mySelectedSlots);
                document.getElementById('stateAfter').textContent = `å·²æ¢å¤ (${recoveredSlots.length} ä¸ªæ—¶é—´æ®µ)`;
                
                const isMatch = savedState.selectedSlots.length === recoveredSlots.length &&
                               savedState.selectedSlots.every(slot => recoveredSlots.includes(slot));
                
                document.getElementById('stateMatch').textContent = isMatch ? 'âœ… åŒ¹é…' : 'âŒ ä¸åŒ¹é…';
                updateRecoveryStatus(isMatch ? 'success' : 'error');
                
                log(`çŠ¶æ€æ¢å¤${isMatch ? 'æˆåŠŸ' : 'å¤±è´¥'}`, isMatch ? 'success' : 'error');
            }, 2000);
        }

        async function validateRoomData() {
            if (!currentEventId) {
                log('è¯·å…ˆåŠ å…¥æˆ¿é—´', 'error');
                return;
            }
            
            try {
                const response = await fetch(`${API_BASE}/responses/room/${currentEventId}`);
                const data = await response.json();
                
                if (data.success) {
                    log(`æˆ¿é—´æ•°æ®éªŒè¯æˆåŠŸï¼š`, 'success');
                    log(`- äº‹ä»¶ï¼š${data.data.event.title}`);
                    log(`- å‚ä¸è€…ï¼š${data.data.participantCount}`);
                    log(`- å“åº”æ•°ï¼š${data.data.responseCount}`);
                    log(`- çƒ­åŠ›å›¾æ•°æ®ç‚¹ï¼š${data.data.heatmapData.length}`);
                } else {
                    throw new Error(data.message);
                }
            } catch (error) {
                log(`æˆ¿é—´æ•°æ®éªŒè¯å¤±è´¥ï¼š${error.message}`, 'error');
            }
        }

        function updateRecoveryStatus(status) {
            const statusSpan = document.getElementById('recovery-status');
            statusSpan.className = `status ${status}`;
            statusSpan.textContent = status === 'success' ? 'âœ… æ¢å¤æˆåŠŸ' : status === 'error' ? 'âŒ æ¢å¤å¤±è´¥' : 'â³ æµ‹è¯•ä¸­';
        }
    </script>
</body>
</html> 